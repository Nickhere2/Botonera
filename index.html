<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Centro de Búsqueda y Accesos</title>
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
  <style>
    /* Estilos generales */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f0f2f5;
      color: #333;
      transition: background-color 0.3s, color 0.3s;
    }
    /* Modo oscuro */
    body.dark {
      background-color: #181818;
      color: #ddd;
    }
    body.dark .card,
    body.dark .bg-white {
      background-color: #282828;
      color: #ddd;
    }
    body.dark input, body.dark select, body.dark textarea {
      background-color: #3a3a3a;
      color: #ddd;
      border-color: #555;
    }
     /* Estilos para botones de filtro en modo oscuro */
    body.dark .filter-btn {
        background-color: #3a3a3a;
        color: #ddd;
    }
     body.dark .filter-btn.active {
        background-color: #3b82f6; /* Blue color for active in dark mode */
        color: white;
     }

    /* Navegación y transiciones */
    .nav-btn {
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    .nav-btn:after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 0.15rem;
      background-color: #3b82f6;
      transform: scaleX(0);
      transition: transform 0.3s ease;
    }
    .nav-btn.active:after {
      transform: scaleX(1);
    }
    .nav-btn:hover {
      transform: translateY(-3px);
    }
    .search-container {
      max-width: 800px;
      margin: 0 auto;
    }
    .card {
      transition: all 0.3s ease;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      border-radius: 8px;
      position: relative;
      display: flex; /* Use flexbox for card content */
      flex-direction: column;
       cursor: grab; /* Indicate draggable */
    }
     .card:active {
         cursor: grabbing; /* Indicate dragging */
     }
     .card .card-content { /* Wrapper for content excluding edit/delete buttons */
        flex-grow: 1;
     }
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 10px 15px rgba(0,0,0,0.15);
    }
     .card.dragging { /* Style for the dragged card */
        opacity: 0.5;
        /* border: 2px dashed #3b82f6; /* Optional: Add border to the dragged card itself */
     }
     /* Style to indicate drop target position */
     .card.drag-over-top { /* Más específico para asegurar que se aplique a la tarjeta */
         border-top: 2px dashed #000 !important; /* Usar !important para sobrescribir posibles conflictos */
         /* Asegurarse de que el borde no se superponga con el contenido */
         /* padding-top: calc(0.5rem - 2px); /* Ajustar padding si es necesario para que el borde no "empuje" */
         /* box-sizing: border-box; /* Ensure padding is included in the element's total height/width */
     }
      /* Estilo para indicar drop en el contenedor vacío o al final */
     .drag-over-container {
         border: 2px dashed #000 !important; /* Usar !important */
     }


    .link-btn,
    .prompt-btn {
      transition: all 0.2s ease;
    }
    .link-btn:hover,
    .prompt-btn:hover {
      transform: translateY(-2px);
    }
    .tooltip {
      visibility: hidden;
      background-color: rgba(0,0,0,0.8);
      color: #fff;
      text-align: center;
      border-radius: 6px;
      padding: 2px 6px;
      position: absolute;
      z-index: 1;
      bottom: 105%;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0;
      transition: opacity 0.3s;
      font-size: 0.7rem;
      white-space: nowrap;
    }
    .tooltip-container:hover .tooltip {
      visibility: visible;
      opacity: 1;
    }
    .engine-icon {
      width: 20px;
      height: 20px;
      object-fit: contain;
      margin-right: 5px;
    }
    .link-icon {
      width: 24px;
      height: 24px;
      object-fit: contain;
    }
    .dropdown-menu {
      max-height: 300px;
      overflow-y: auto;
    }
    .dropdown-item {
      display: flex;
      align-items: center;
      padding: 8px 12px;
    }
    .dropdown-item:hover {
      background-color: #f3f4f6;
    }
    .filter-btn.active {
      background-color: #3b82f6;
      color: white;
    }
    .no-scrollbar::-webkit-scrollbar {
      display: none;
    }
    .no-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    .category-title {
      position: relative;
      overflow: hidden;
      padding-bottom: 10px;
    }
    .category-title:after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 2px;
      background: linear-gradient(to right, #3b82f6, transparent);
    }
    /* Panel de edición */
    #editPanel {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(255,255,255,0.95);
      z-index: 1000;
      overflow-y: auto;
      transition: opacity 0.3s;
    }
    body.dark #editPanel {
      background-color: rgba(30,30,30,0.95);
    }
    .prompt-content,
    .note-content,
    .task-content {
      max-height: 150px;
      overflow-y: auto;
      font-size: 0.8rem;
    }
    .task-item.completed {
        text-decoration: line-through;
        color: #6b7280; /* gray-500 */
    }
     /* Estilo para la lista de tareas */
     .task-list {
         list-style: none;
         padding: 0;
         margin: 0;
     }
     .task-list li {
         margin-bottom: 4px;
         display: flex;
         align-items: center;
     }
     .task-list input[type="checkbox"] {
         margin-right: 8px;
     }

    @media print {
      .page-break {
        page-break-after: avoid;
      }
      body {
        width: 100%;
      }
    }
    /* Clases para iconos con colores originales */
    .icon-google { color: #4285F4; }
    .icon-youtube { color: #FF0000; }
    .icon-facebook { color: #1877F2; }
    .icon-twitter { color: #1DA1F2; }
    .icon-instagram { color: #E4405F; }
    .icon-linkedin { color: #0A66C2; }
    .icon-whatsapp { color: #25D366; }
    .icon-spotify { color: #1DB954; }
    .icon-microsoft { color: #00A1F1; }
    .icon-imdb { color: #F5DE50; }
    /* Estilos para la vista previa en tiempo real */
    #livePreview {
      margin-top: 1rem;
    }
    /* Estilos del botón de modo oscuro */
    #toggleDarkMode {
      position: fixed;
      top: 1rem;
      right: 1rem;
      background-color: #3b82f6;
      border: none;
      color: #fff;
      padding: 0.5rem; /* Adjusted padding for icon only */
      border-radius: 9999px;
      cursor: pointer;
      transition: background-color 0.3s;
      z-index: 1100;
      width: 40px; /* Fixed width and height for a round button */
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #toggleDarkMode:hover {
      background-color: #2563eb;
    }
     #toggleDarkMode i {
         margin-right: 0; /* Remove margin for icon only */
     }
     #toggleDarkMode .mode-text {
         display: none; /* Hide the text */
     }

    /* Estilos para el botón de edición principal (icono) */
    #mainEditButton {
        position: fixed;
        top: 4.5rem; /* Ajusta la posición para que esté debajo del botón de modo oscuro */
        right: 1rem; /* Alineado a la derecha como el botón de modo oscuro */
        background-color: #6b7280; /* gray-500 */
        border: none;
        color: #fff;
        padding: 0.5rem; /* Ajusta el padding para que sea redondo */
        border-radius: 9999px;
        cursor: pointer;
        transition: background-color 0.3s;
        z-index: 1100;
        width: 40px; /* Mismo tamaño que el botón de modo oscuro */
        height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    #mainEditButton:hover {
        background-color: #4b5563; /* gray-700 */
    }
     #mainEditButton i {
         margin-right: 0; /* Elimina el margen para que solo se vea el icono */
     }


    /* Estilos para edición en línea */
    .card .display-mode { display: block; }
    .card .edit-mode { display: none; }
    .card.editing .display-mode { display: none; }
    .card.editing .edit-mode { display: block; }
    .card .edit-mode input,
    .card .edit-mode textarea,
    .card .edit-mode select {
        width: 100%;
        padding: 0.25rem;
        border: 1px solid #ccc;
        border-radius: 4px;
        margin-bottom: 0.5rem;
        color: #333; /* Ensure text is visible in dark mode */
    }
     body.dark .card .edit-mode input,
     body.dark .card .edit-mode textarea,
     body.dark .card .edit-mode select {
         background-color: #3a3a3a;
         color: #ddd;
         border-color: #555;
     }
     .search-term-button {
         background-color: #e2e8f0; /* gray-200 */
         color: #4a5568; /* gray-700 */
         padding: 0.2rem 0.5rem;
         border-radius: 4px;
         font-size: 0.75rem;
         cursor: pointer;
         margin-left: 5px;
         transition: background-color 0.2s;
         flex-shrink: 0; /* Prevent button from shrinking */
     }
     .search-term-button:hover {
         background-color: #cbd5e0; /* gray-300 */
     }
     body.dark .search-term-button {
         background-color: #4a5568; /* gray-700 */
         color: #e2e8f0; /* gray-200 */
     }
      body.dark .search-term-button:hover {
         background-color: #6366f1; /* indigo-500 */
      }


  </style>
</head>
<body class="min-h-screen">
  <button id="toggleDarkMode" class="flex items-center justify-center">
      <i class="fas fa-moon"></i> <span class="mode-text">Modo Oscuro</span>
  </button>

   <button id="mainEditButton" class="flex items-center justify-center">
       <i class="fas fa-edit"></i>
   </button>


  <div class="container mx-auto px-4 py-8">
    <h1 class="text-4xl font-bold text-center text-blue-600 mb-8">Centro de Búsqueda y Accesos</h1>

    <div class="flex justify-center space-x-4 mb-8">
      <button id="nav-buscadores" class="nav-btn active flex items-center justify-center bg-white py-3 px-6 rounded-lg shadow-md text-lg font-semibold">
        <i class="fas fa-search mr-2"></i> Buscadores
      </button>
      <button id="nav-links" class="nav-btn flex items-center justify-center bg-white py-3 px-6 rounded-lg shadow-md text-lg font-semibold">
        <i class="fas fa-link mr-2"></i> Links
      </button>
      <button id="nav-prompts" class="nav-btn flex items-center justify-center bg-white py-3 px-6 rounded-lg shadow-md text-lg font-semibold">
        <i class="fas fa-brain mr-2"></i> Prompts
      </button>
       <button id="nav-notes" class="nav-btn flex items-center justify-center bg-white py-3 px-6 rounded-lg shadow-md text-lg font-semibold">
        <i class="fas fa-sticky-note mr-2"></i> Notas
      </button>
       <button id="nav-tasks" class="nav-btn flex items-center justify-center bg-white py-3 px-6 rounded-lg shadow-md text-lg font-semibold">
        <i class="fas fa-tasks mr-2"></i> Tareas
      </button>
    </div>

    <div id="section-buscadores" class="section">
      <div class="search-container mb-8">
        <div class="relative">
          <div class="flex">
            <input type="text" id="searchInput" list="searchSuggestions" placeholder="Ingresa tu búsqueda aquí..." class="w-full px-4 py-3 border border-gray-300 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-lg">
            <datalist id="searchSuggestions"></datalist>
            <div class="relative">
              <button id="dropdownToggle" class="bg-blue-600 text-white px-4 py-3 rounded-r-lg flex items-center">
                <span id="selectedEngine">Google</span>
                <i class="fas fa-chevron-down ml-2"></i>
              </button>
              <div id="searchEngineDropdown" class="hidden absolute right-0 top-full mt-1 w-64 bg-white rounded-md shadow-lg z-10 dropdown-menu"></div>
            </div>
          </div>
          <button id="searchButton" class="mt-3 bg-blue-600 hover:bg-blue-700 text-white w-full py-3 rounded-lg flex items-center justify-center text-lg font-medium">
            <i class="fas fa-search mr-2"></i> Buscar
          </button>
        </div>
      </div>

      <h2 class="text-2xl font-bold mb-4">Filtrar por categoría</h2>
      <div id="searchFilterButtons" class="flex flex-wrap gap-2 mb-4"></div>
       <div class="search-container mb-8">
         <input type="text" id="searchCardSearchInput" placeholder="Buscar Buscadores..." class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-lg">
       </div>

      <div id="searchEnginesContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
       <div id="noBuscadoresFound" class="hidden text-center text-gray-600 mt-8">No se encontraron buscadores que coincidan con los filtros.</div>
    </div>

    <div id="section-links" class="section hidden">
       <h2 class="text-2xl font-bold mb-4">Filtrar por categoría</h2>
       <div id="linkFilterButtons" class="flex flex-wrap gap-2 mb-4"></div>
        <div class="search-container mb-8">
         <input type="text" id="linkCardSearchInput" placeholder="Buscar Links..." class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-lg">
       </div>
      <div id="linksContainer" class="space-y-8"></div>
       <div id="noLinksFound" class="hidden text-center text-gray-600 mt-8">No se encontraron links que coincidan con los filtros.</div>
    </div>

    <div id="section-prompts" class="section hidden">
       <h2 class="text-2xl font-bold mb-4">Filtrar por categoría</h2>
       <div id="promptFilterButtons" class="flex flex-wrap gap-2 mb-4"></div>
        <div class="search-container mb-8">
         <input type="text" id="promptCardSearchInput" placeholder="Buscar Prompts..." class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-lg">
       </div>
      <div id="promptsContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
       <div id="noPromptsFound" class="hidden text-center text-gray-600 mt-8">No se encontraron prompts que coincidan con los filtros.</div>
    </div>

     <div id="section-notes" class="section hidden">
       <h2 class="text-2xl font-bold mb-4">Filtrar por categoría</h2>
       <div id="noteFilterButtons" class="flex flex-wrap gap-2 mb-4"></div>
        <div class="search-container mb-8">
           <input type="text" id="noteCardSearchInput" placeholder="Buscar Notas..." class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-yellow-500 text-lg">
         </div>
       <div id="notesContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
        <div id="noNotesFound" class="hidden text-center text-gray-600 mt-8">No se encontraron notas que coincidan con los filtros.</div>
     </div>

     <div id="section-tasks" class="section hidden">
        <h2 class="text-2xl font-bold mb-4">Filtrar por categoría</h2>
        <div id="taskFilterButtons" class="flex flex-wrap gap-2 mb-4"></div>
         <div class="search-container mb-8">
           <input type="text" id="taskCardSearchInput" placeholder="Buscar Tareas..." class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500 text-lg">
         </div>
       <div id="tasksContainer" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4"></div>
        <div id="noTasksFound" class="hidden text-center text-gray-600 mt-8">No se encontraron tareas que coincidan con los filtros.</div>
     </div>


    <div id="editPanel" class="hidden">
      <div class="container mx-auto px-4 py-8">
        <div class="flex justify-between items-center mb-6">
          <h2 class="text-2xl font-bold">Panel de Edición</h2>
          <button id="closeEditButton" class="bg-gray-200 hover:bg-gray-300 p-2 rounded-full">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="mb-6 p-4 bg-gray-100 rounded-lg">
          <p class="text-sm text-gray-600">
            Usa este panel para editar los elementos existentes o agregar nuevos. Los cambios en tiempo real se reflejarán en la vista previa.
          </p>
           <div class="mt-4">
              <button id="exportDataButton" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-md mr-2"><i class="fas fa-download mr-2"></i> Exportar Datos (JSON)</button>
              <input type="file" id="importDataInput" accept=".json" class="hidden">
              <button id="importDataButton" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md"><i class="fas fa-upload mr-2"></i> Importar Datos (JSON)</button>
           </div>
        </div>
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
          <h3 class="text-xl font-semibold mb-4">Agregar nuevo elemento</h3>
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
            <div>
              <label class="block text-sm font-medium mb-1">Título</label>
              <input type="text" id="newTitle" placeholder="Ej: Google" class="w-full px-3 py-2 border border-gray-300 rounded-md">
            </div>
            <div>
              <label class="block text-sm font-medium mb-1">Acción (URL, texto, descripción)</label>
               <div class="flex items-center">
                  <input type="text" id="newAction" placeholder="Ej: https://www.google.com/search?q={search_term}" class="w-full px-3 py-2 border border-gray-300 rounded-md">
                   <button class="search-term-button hidden" data-input-id="newAction">{search_term}</button>
               </div>
            </div>
            <div>
              <label class="block text-sm font-medium mb-1">Tipo</label>
              <select id="newType" class="w-full px-3 py-2 border border-gray-300 rounded-md">
                <option value="Buscador">Buscador</option>
                <option value="Link">Link</option>
                <option value="Promp">Prompt</option>
                <option value="Nota">Nota</option>
                <option value="Tarea">Tarea</option>
              </select>
            </div>
            <div>
              <label class="block text-sm font-medium mb-1">Categoría</label>
              <input type="text" id="newCategory" placeholder="Ej: Búsqueda / Herramientas de IA" class="w-full px-3 py-2 border border-gray-300 rounded-md">
            </div>
            <div class="md:col-span-2">
              <label class="block text-sm font-medium mb-1">Icono (Clase FontAwesome o URL)</label>
              <input type="text" id="newIcon" placeholder='Ej: "fab fa-google" para Google' class="w-full px-3 py-2 border border-gray-300 rounded-md">
            </div>
          </div>
          <div id="livePreview" class="mb-4"></div>
          <button id="addItemButton" class="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded-md">
            <i class="fas fa-plus mr-2"></i> Agregar elemento
          </button>
        </div>

        <div class="bg-white rounded-lg shadow-md p-6 overflow-x-auto">
          <h3 class="text-xl font-semibold mb-4">Editar elementos existentes</h3>
          <table class="min-w-full divide-y divide-gray-200">
            <thead>
              <tr>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Título</th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Acción</th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Tipo</th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Categoría</th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Icono</th>
                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Acciones</th>
              </tr>
            </thead>
            <tbody id="itemsTableBody" class="bg-white divide-y divide-gray-200"></tbody>
          </table>
          <p class="mt-2 text-sm text-gray-600">
            Para actualizar un elemento, modifica los datos y haz clic en el icono de guardar; para eliminar, haz clic en el icono de borrar.
          </p>
        </div>

        <div class="mt-6 flex justify-end">
          </div>
      </div>
    </div>

    <div id="toast" class="hidden fixed bottom-20 right-5 bg-green-600 text-white py-2 px-4 rounded-md shadow-lg">
      Copiado al portapapeles
    </div>
  </div>

  <script>
    // Datos de la aplicación (se cargarán desde localStorage)
    let data = []; // Ahora 'data' es el array global

    // Variables globales para Drag & Drop
    let draggedCard = null;


    // --- Funciones Auxiliares ---

    // Función auxiliar para obtener el HTML del icono con el color adecuado
    function getIconHtml(item, isPrompt = false) {
      if (!item.icon) {
         if (item.type === 'Nota') return `<i class="fas fa-sticky-note text-yellow-500 text-xl"></i>`;
         if (item.type === 'Tarea') return `<i class="fas fa-tasks text-teal-500 text-xl"></i>`;
        return `<i class="${isPrompt ? "fas fa-comment" : "fas fa-search"} ${isPrompt ? "text-purple-600" : "text-blue-600"} text-xl"></i>`;
      }
      let colorClass = "";
      const iconStr = item.icon;
      if (iconStr.includes("fa-google")) colorClass = "icon-google";
      else if (iconStr.includes("fa-youtube")) colorClass = "icon-youtube";
      else if (iconStr.includes("fab fa-facebook")) colorClass = "icon-facebook"; // Corrected class name
      else if (iconStr.includes("fab fa-twitter")) colorClass = "icon-twitter"; // Corrected class name
      else if (iconStr.includes("fab fa-instagram")) colorClass = "icon-instagram"; // Corrected class name
      else if (iconStr.includes("fab fa-linkedin")) colorClass = "icon-linkedin"; // Corrected class name
      else if (iconStr.includes("fab fa-whatsapp")) colorClass = "icon-whatsapp"; // Corrected class name
      else if (iconStr.includes("fab fa-spotify")) colorClass = "icon-spotify"; // Corrected class name
      else if (iconStr.includes("fab fa-microsoft")) colorClass = "icon-microsoft"; // Corrected class name
      else if (iconStr.includes("fab fa-imdb")) colorClass = "icon-imdb"; // Corrected class name
      else if (iconStr.includes("fa-map-marker-alt")) colorClass = "text-red-500";
      else if (iconStr.includes("fa-book") && !iconStr.includes("fa-book-open")) colorClass = "text-green-600";
      else if (iconStr.includes("fa-book-open")) colorClass = "text-purple-500";
      else if (iconStr.includes("fa-images")) colorClass = "text-pink-500";
      else if (iconStr.includes("fa-music")) colorClass = "text-purple-500";
      else if (iconStr.includes("fa-film")) colorClass = "text-blue-500";
      else if (iconStr.includes("fa-video")) colorClass = "text-red-500";
      else if (iconStr.includes("fa-envelope")) colorClass = "text-orange-500";
      else if (iconStr.includes("fa-palette")) colorClass = "text-pink-500";
      else if (iconStr.includes("fa-cloud-sun")) colorClass = "text-yellow-500";
      else if (iconStr.includes("fa-calendar-day")) colorClass = "text-blue-500";
      else if (iconStr.includes("fa-calendar-alt")) colorClass = "text-blue-500";
      else if (iconStr.includes("fa-futbol")) colorClass = "text-green-500";
      else if (iconStr.includes("fa-laptop-code")) colorClass = "text-gray-700";
      else if (iconStr.includes("fa-brain")) colorClass = "text-purple-500";
      else if (iconStr.includes("fas fa-search")) colorClass = "text-blue-500"; // Adjusted from original code
      else if (iconStr.includes("fa-paint-brush")) colorClass = "text-pink-500";
      else if (iconStr.includes("fa-comment-dots")) colorClass = "text-blue-500";
      else if (iconStr.includes("fas fa-comment")) colorClass = "text-blue-600"; // Adjusted from original code
      else if (iconStr.includes("fas fa-robot")) colorClass = "text-green-500"; // Adjusted from original code
      else if (iconStr.includes("fas fa-sparkles")) colorClass = "text-yellow-400";
      else if (iconStr.includes("fas fa-moon")) colorClass = "text-gray-500";
      else if (iconStr.includes("fas fa-child")) colorClass = "text-pink-500";
      else if (iconStr.includes("fas fa-list")) colorClass = "text-blue-500";
      else if (iconStr.includes("fas fa-puzzle-piece")) colorClass = "text-yellow-500";
      else if (iconStr.includes("fas fa-edit")) colorClass = "text-green-600";
      else if (iconStr.includes("fas fa-thumbs-up")) colorClass = "text-blue-500";
      else if (iconStr.includes("fas fa-user-tie")) colorClass = "text-gray-700";
      else if (iconStr.includes("fab fa-python")) colorClass = "text-blue-800";
      else if (iconStr.includes("fas fa-code")) colorClass = "text-gray-800";
      else if (iconStr.includes("fas fa-magic")) colorClass = "text-purple-500";
      else if (iconStr.includes("fas fa-infinity")) colorClass = "text-blue-500";
      else if (iconStr.includes("fab fa-pinterest")) colorClass = "text-red-600";
      else if (iconStr.includes("fab fa-wikipedia-w")) colorClass = "text-gray-700";
      else if (iconStr.includes("fas fa-shopping-cart")) colorClass = "text-blue-600";
      else if (iconStr.includes("fas fa-laptop")) colorClass = "text-gray-700";
      else if (iconStr.includes("fas fa-sticky-note")) colorClass = "text-yellow-500";
      else if (iconStr.includes("fas fa-tasks")) colorClass = "text-teal-500";
       else if (iconStr.includes("fas fa-lightbulb")) colorClass = "text-yellow-400"; // Color para la bombilla


      if (!colorClass) {
        colorClass = isPrompt ? "text-purple-600" : (item.type === 'Nota' ? "text-yellow-500" : (item.type === 'Tarea' ? "text-teal-500" : "text-blue-600"));
      }
      return `<i class="${item.icon} ${colorClass} text-xl"></i>`;
    }

    // Show/hide search term button based on selected type in Add New Item
    function toggleSearchTermButton() {
        const newType = document.getElementById("newType").value;
        const searchTermButton = document.querySelector("#editPanel .search-term-button");
        if (newType === "Buscador") {
            searchTermButton.classList.remove("hidden");
        } else {
            searchTermButton.classList.add("hidden");
        }
    }

    // Actualización en vivo de la vista previa al agregar un nuevo elemento
    function updateLivePreview() {
      const title = document.getElementById("newTitle").value.trim() || "Título";
      const action = document.getElementById("newAction").value.trim() || "Acción";
      const type = document.getElementById("newType").value;
      const category = document.getElementById("newCategory").value.trim() || "Categoría";
      const icon = document.getElementById("newIcon").value.trim() || "";
      const previewContainer = document.getElementById("livePreview");
      // Assign a temporary ID for preview purposes
      const tempItem = { title, action, type, category, icon, id: 'preview' };
      let contentHtml = '';
      if (type === 'Promp') {
         contentHtml = `<div class="mt-3 bg-gray-50 p-2 rounded text-sm text-gray-700 prompt-content no-scrollbar">${action.replace(/\n/g, "<br>").substring(0, 100) + (action.length > 100 ? '...' : '')}</div>`;
      } else if (type === 'Nota') {
         contentHtml = `<div class="mt-3 bg-gray-50 p-2 rounded text-sm text-gray-700 note-content no-scrollbar">${action.replace(/\n/g, "<br>").substring(0, 100) + (action.length > 100 ? '...' : '')}</div>`;
      } else if (type === 'Tarea') {
          // Display task action as a simple list in preview
          const taskLines = action.split('\n').filter(line => line.trim() !== '');
          let taskListHtml = '<ul class="task-list mt-3 bg-gray-50 p-2 rounded text-sm text-gray-700 no-scrollbar">';
          taskLines.forEach(line => {
              // Check if the line starts with "[x]" or "[ ]" to determine initial checked state
              const isChecked = line.trim().startsWith('[x]');
              const cleanedLine = line.replace(/^\[[x ]\]\s*/, '').trim(); // Remove "[x] " or "[ ] "
              taskListHtml += `<li><input type="checkbox" disabled ${isChecked ? 'checked' : ''}> ${cleanedLine}</li>`;
          });
          taskListHtml += '</ul>';
          contentHtml = taskListHtml;
      } else { // Buscador or Link
         contentHtml = `<p class="text-sm text-gray-600 mt-2">${action.substring(0, 100) + (action.length > 100 ? '...' : '')}</p>`;
      }


      let html = `<div class="card bg-white p-4 rounded-lg mb-2" title="Vista previa en tiempo real">
                    <div class="display-mode card-content">
                      <div class="flex items-center">
                        ${getIconHtml(tempItem, type==="Promp")}
                        <h4 class="text-lg font-medium ml-2">${title}</h4>
                      </div>
                      ${contentHtml}
                      <div class="mt-2 text-xs text-gray-500">Etiqueta: ${category}</div>
                       <button class="edit-btn text-blue-600 mt-2 text-xs" style="pointer-events: none;">
                        <i class="fas fa-edit"></i> Editar (previsualización)
                      </button>
                    </div>
                    <div class="tooltip">Arrastra para reordenar (previsualización)</div> </div>`;
      previewContainer.innerHTML = html;
       // Add DnD in the preview (optional, might be confusing)
      // const card = previewContainer.querySelector(".card");
      // if(card) addDragAndDropListeners(card);
    }

    function showToast(message) {
      console.log("Mostrando toast:", message); // Log toast message
      const toast = document.getElementById("toast");
      toast.textContent = message;
      toast.classList.remove("hidden");
      setTimeout(() => { toast.classList.add("hidden"); }, 3000);
    }

    function saveData(currentData) {
      console.log("Guardando datos en localStorage:", currentData.length, "items"); // Log save
      localStorage.setItem("centroAccesosData", JSON.stringify(currentData));
       console.log("Datos guardados."); // Log save complete
    }

    // Function to update an item in the data array and re-render
    function updateItem(itemId, updatedItem) {
       console.log(`Actualizando elemento con ID ${itemId}:`, updatedItem); // Log update
       const itemIndex = data.findIndex(item => item.id == itemId);
       if (itemIndex > -1) {
         // Preserve existing properties like 'completed' for tasks if not explicitly updated
         // Use spread operator carefully to ensure updatedItem properties overwrite existing ones
         data[itemIndex] = { ...data[itemIndex], ...updatedItem };
         saveData(data);
         initializeUI(data); // Re-render all sections
         // populateEditTable(data); // Called within initializeUI
         showToast("Elemento actualizado correctamente");
       } else {
           console.warn(`Elemento con ID ${itemId} no encontrado para actualizar.`); // Log warning
       }
    }

    // Function to delete an item from the data array and re-render
    function deleteItem(itemId) {
      console.log(`Eliminando elemento con ID ${itemId}`); // Log deletion
      const initialLength = data.length;
      data = data.filter(item => item.id != itemId);
      if (data.length < initialLength) {
        saveData(data);
        // populateEditTable(data); // Re-populating initializeUI covers this
        initializeUI(data); // Re-render all sections and re-populate the table within it
        showToast("Elemento eliminado correctamente");
      } else {
           console.warn(`Elemento con ID ${itemId} no encontrado para eliminar.`); // Log warning
      }
    }


    // --- Funciones de Drag & Drop ---

    let draggedCard = null; // Moved global variable declaration here

    function handleDragStart(e) {
      draggedCard = this;
      e.dataTransfer.effectAllowed = "move";
      // Store the ID and type of the dragged card
      e.dataTransfer.setData("text/plain", JSON.stringify({ id: this.dataset.id, type: this.dataset.type }));
       // Add a class to the dragged card for visual feedback
       setTimeout(() => {
           if(draggedCard) draggedCard.classList.add('dragging'); // Check if draggedCard is still valid
       }, 0); // Use setTimeout to allow the drag image to be set before adding the class
       console.log("Drag start:", this.dataset.id, "Type:", this.dataset.type);
    }

    function handleDragOver(e) {
      if (e.preventDefault) e.preventDefault();
      e.dataTransfer.dropEffect = "move";
      const targetCard = e.target.closest(".card:not(.editing)"); // Encuentra el .card más cercano que no esté editando
      // Remove previous drag-over classes from all cards and containers
      document.querySelectorAll('.card').forEach(card => card.classList.remove('drag-over-top'));
      document.querySelectorAll('.category-engines, .category-links, .category-prompts, .category-notes, .category-tasks').forEach(container => container.classList.remove('drag-over-container'));


      if (targetCard && targetCard !== draggedCard) {
         // Only add class if the target is a different card within the same type
         if (draggedCard && targetCard.dataset.type === draggedCard.dataset.type) {
             console.log("DragOver: Target card found and type matches. Adding drag-over-top to:", targetCard.dataset.id); // Add this log
             targetCard.classList.add('drag-over-top'); // Indicate dropping *before* this card
         } else {
              console.log("DragOver: Target card found but type mismatch or is dragged card itself.");
         }

      } else if (!targetCard && e.target.closest('.category-engines, .category-links, .category-prompts, .category-notes, .category-tasks')) {
          // If dragging over a category container itself (not over a specific card)
           const container = e.target.closest('.category-engines, .category-links, .category-prompts, .category-notes, .category-tasks');
           const containerType = container.closest('.section').id.replace('section-', '');
           const draggedType = draggedCard ? draggedCard.dataset.type : null; // Get type from dragged card

           // Match container type with dragged type (handling pluralization)
           const isTypeMatch = draggedType && (
               (draggedType === 'Buscador' && containerType === 'buscadores') ||
               (draggedType === 'Link' && containerType === 'links') ||
               (draggedType === 'Promp' && containerType === 'prompts') ||
                (draggedType === 'Nota' && containerType === 'notes') || // Corrected type check
                (draggedType === 'Tarea' && containerType === 'tasks') // Corrected type check
               );

           if (isTypeMatch) {
               console.log("DragOver: Target container found and type matches.", containerType); // Add this log
               container.classList.add('drag-over-container'); // Indicate dropping at the end of the container
           } else {
               console.log("DragOver: Target container found but type mismatch.");
           }
      } else {
           console.log("DragOver: No valid target card or container found.");
      }
      return false; // Return false to allow the drop
    }

    function handleDragLeave(e) {
       // This event is tricky, it fires when leaving the element AND its children.
       // For simplicity, we handle most cleanup in dragover and dragend.
       // We can remove the class from the exact element being left, but dragover re-adds it if needed.
       // Adding a small timeout can help prevent flickering if just moving over children
       setTimeout(() => {
           const targetCard = e.target.closest(".card");
           if (targetCard && !targetCard.matches(':hover')) { // Check if not hovering over the element or its children anymore
             targetCard.classList.remove('drag-over-top');
             console.log("DragLeave: Removing drag-over-top from card.");
           }
            const targetContainer = e.target.closest('.category-engines, .category-links, .category-prompts, .category-notes, .category-tasks');
            if (targetContainer && !targetContainer.matches(':hover')) { // Check if not hovering over the container or its children
                 targetContainer.classList.remove('drag-over-container');
                 console.log("DragLeave: Removing drag-over-container from container.");
            }
       }, 50); // Small delay
    }

    function handleDrop(e) {
      if (e.stopPropagation) e.stopPropagation();
      e.preventDefault(); // Crucial to allow drop


      const targetCard = e.target.closest(".card:not(.editing)"); // Element DOM sobre el que se soltó
      const targetContainer = e.target.closest('.category-engines, .category-links, .category-prompts, .category-notes, .category-tasks');


      // Clean up visual feedback before processing
      document.querySelectorAll('.card').forEach(card => card.classList.remove('drag-over-top'));
      document.querySelectorAll('.category-engines, .category-links, .category-prompts, .category-notes, .category-tasks').forEach(container => container.classList.remove('drag-over-container'));


      if (!draggedCard) {
         console.warn("Drop cancelado: draggedCard es nulo.");
         return false; // Indicate drop failure
      }

      try {
          const draggedInfo = JSON.parse(e.dataTransfer.getData("text/plain"));
          const draggedCardId = draggedInfo.id;
          const draggedCardType = draggedInfo.type;

          // Find the data of the dragged item before removing it
          const originalDraggedIndex = data.findIndex(item => item.id == draggedCardId);
           if (originalDraggedIndex === -1) {
               console.error("Elemento arrastrado no encontrado en los datos.");
               return false; // Indicate drop failure
           }
           const movedItemData = data[originalDraggedIndex]; // Get data before splicing


          let insertionIndex = data.length; // Default to appending at the end

          if (targetCard && draggedCard !== targetCard) {
            const targetCardId = targetCard.dataset.id;
            const targetCardType = targetCard.dataset.type;

             // Ensure dropping within the same section type
            if (draggedCardType === targetCardType) {
                 // Find the target index in the data array *BEFORE* removing the dragged item
                const originalTargetIndex = data.findIndex(item => item.id == targetCardId);

                if (originalTargetIndex === -1) {
                    console.warn("Target item not found in data array during drop.");
                    // Fallback: if target not found in data, append to end (less ideal)
                    insertionIndex = data.length;
                    showToast("Error al encontrar objetivo. Elemento movido al final.");
                } else {
                     // Calculate the insertion index *after* removing the dragged item
                     if (originalDraggedIndex < originalTargetIndex) {
                         // If the dragged item was originally before the target, the target's index
                         // in the array after removal is one less than its original index.
                         insertionIndex = originalTargetIndex - 1;
                     } else {
                         // If the dragged item was originally after the target, the target's index
                         // in the array after removal is the same as its original index.
                         insertionIndex = originalTargetIndex;
                     }
                     console.log(`Calculated insertion index based on data indices: originalDragged=${originalDraggedIndex}, originalTarget=${originalTargetIndex}, insertion=${insertionIndex}`);
                }

            } else {
                showToast(`No se puede mover un elemento de "${draggedCardType}" a la sección de "${targetCardType}".`);
                 console.log("Drop entre tipos de sección no permitido.");
                return false; // Prevent drop if types don't match
            }
          } else if (targetContainer && !targetCard && draggedCard) {
             // Dropped in an empty container or at the end of a container area
             const containerType = targetContainer.closest('.section').id.replace('section-', '');
             const draggedType = draggedCard.dataset.type;

             // Match container type with dragged type (handling pluralization)
             const isTypeMatch =
                 (draggedType === 'Buscador' && containerType === 'buscadores') ||
                 (draggedType === 'Link' && containerType === 'links') ||
                 (draggedType === 'Promp' && containerType === 'prompts') ||
                  (draggedType === 'Nota' && containerType === 'notes') ||
                  (draggedType === 'Tarea' && containerType === 'tasks');

             if (isTypeMatch) {
                 insertionIndex = data.length; // Append to the end of the data array
                 console.log(`Dropped in container of type ${containerType}. Appending to end.`);
             } else {
                 showToast(`No se puede mover un elemento de "${draggedType}" a la sección de "${containerType}".`);
                  console.log("Drop entre tipos de sección no permitido en contenedor.");
                 return false; // Prevent drop if types don't match the container
             }
          } else {
              console.log("Dropped on dragged item or outside valid target area.");
              return false; // Dropped on self or invalid area
          }


          // Remove the dragged item from its original position in the data array
           // Ensure originalDraggedIndex is valid before splicing
          if (originalDraggedIndex > -1) {
               data.splice(originalDraggedIndex, 1);

               // Ensure insertionIndex is within bounds for splice (0 to data.length inclusive)
               insertionIndex = Math.max(0, Math.min(insertionIndex, data.length));

               // Insert the item at the new position
               data.splice(insertionIndex, 0, movedItemData);

               console.log("Datos reordenados en memoria:", data.map(b => b.title));

               // Save the updated data to localStorage
               saveData(data);

               // Re-render the UI to reflect the new order
               initializeUI(data); // Re-render all sections

               showToast("Elemento reordenado correctamente.");
               return true; // Indicate drop success


           } else {
               console.error("Elemento arrastrado no encontrado en el array de datos durante la eliminación.");
               return false; // Indicate drop failure
           }
      } catch (error) {
          console.error("Error durante la operación de drop:", error);
           showToast("Ocurrió un error al reordenar el elemento.");
           return false; // Indicate drop failure
      } finally {
           // Ensure dragging class is removed even if an error occurs
           if (draggedCard) {
               draggedCard.classList.remove('dragging');
           }
           draggedCard = null; // Clear dragged item reference
      }
    }


    function handleDragEnd() {
      if (draggedCard) {
         draggedCard.classList.remove('dragging'); // Remove the dragging class
      }
      draggedCard = null;
      // Clean up any visual feedback from target cards and containers
      document.querySelectorAll('.card').forEach(card => card.classList.remove('drag-over-top'));
       document.querySelectorAll('.category-engines, .category-links, .category-prompts, .category-notes, .category-tasks').forEach(container => container.classList.remove('drag-over-container'));

      console.log("Drag end.");
    }


    // Función para agregar atributos de draggable a las tarjetas y sus event listeners
    function addDragAndDropListeners(card) {
      card.setAttribute("draggable", "true");
      // Remove existing listeners to prevent duplicates when re-rendering
      card.removeEventListener("dragstart", handleDragStart);
      card.removeEventListener("dragover", handleDragOver);
      card.removeEventListener("dragleave", handleDragLeave);
      card.removeEventListener("drop", handleDrop);
      card.removeEventListener("dragend", handleDragEnd);

      // Add the listeners
      card.addEventListener("dragstart", handleDragStart, false);
      card.addEventListener("dragover", handleDragOver, false);
      card.addEventListener("dragleave", handleDragLeave, false);
      card.addEventListener("drop", handleDrop, false);
      card.addEventListener("dragend", handleDragEnd, false);
    }


    // --- Funciones de Carga y Renderizado ---


     // New function to specifically load from data.json
     async function loadDataFromJson() {
         try {
             const response = await fetch('data.json');
             if (!response.ok) {
                  console.warn(`No se pudo cargar data.json. Status: ${response.status}. Iniciando con datos vacíos.`);
                  data = [];
             } else {
                 const jsonData = await response.json();
                 console.log("Datos cargados desde data.json:", jsonData);
                 // Ensure loaded data is an array and items have IDs, and tasks have completed status
                 data = Array.isArray(jsonData) ? jsonData.map(item => {
                     if (item.id === undefined || item.id === null) {
                         item.id = Date.now().toString() + Math.floor(Math.random() * 1000000).toString(); // Generate a more unique ID
                     }
                     if (item.type === 'Tarea' && item.completed === undefined) {
                         return { ...item, completed: false };
                     }
                     return item;
                 }) : [];
                 saveData(data); // Save loaded data to localStorage for future use
             }
         } catch (error) {
             console.error("Error al cargar o procesar data.json:", error);
             data = []; // In case of any error, initialize with empty data
         }
          initializeUI(data); // Render UI with loaded data
          setupNavigation();
          setupEventListeners();
          console.log("Carga desde data.json completada.");
     }

    function initializeUI(currentData) {
      console.log("Entrando a initializeUI con datos:", currentData); // Log entry
      if (!currentData || !Array.isArray(currentData) || currentData.length === 0) { // Added Array.isArray check
          console.log("No hay datos o los datos son inválidos para mostrar.");
          // Hide all sections
           document.querySelectorAll(".section").forEach(section => section.classList.add("hidden"));

          // Optionally display a message in each container if data is empty
          document.getElementById("searchEnginesContainer").innerHTML = '<div class="text-center text-gray-600 mt-8 col-span-full">No hay buscadores disponibles.</div>';
          document.getElementById("linksContainer").innerHTML = '<div class="text-center text-gray-600 mt-8 col-span-full">No hay links disponibles.</div>';
          document.getElementById("promptsContainer").innerHTML = '<div class="text-center text-gray-600 mt-8 col-span-full">No hay prompts disponibles.</div>';
          document.getElementById("notesContainer").innerHTML = '<div class="text-center text-gray-600 mt-8 col-span-full">No hay notas disponibles.</div>';
          document.getElementById("tasksContainer").innerHTML = '<div class="text-center text-gray-600 mt-8 col-span-full">No hay tareas disponibles.</div>';

          // Clear filter buttons if no data
          document.getElementById("searchFilterButtons").innerHTML = '';
          document.getElementById("linkFilterButtons").innerHTML = '';
          document.getElementById("promptFilterButtons").innerHTML = '';
          document.getElementById("noteFilterButtons").innerHTML = '';
          document.getElementById("taskFilterButtons").innerHTML = '';

           // Hide "No items found" messages initially
           document.getElementById("noBuscadoresFound").classList.add("hidden");
           document.getElementById("noLinksFound").classList.add("hidden");
           document.getElementById("noPromptsFound").classList.add("hidden");
           document.getElementById("noNotesFound").classList.add("hidden");
           document.getElementById("noTasksFound").classList.add("hidden");

           // Show the first section's container to make it visible even if empty
           document.getElementById("section-buscadores").classList.remove("hidden");
            // Ensure navigation buttons are reset
            document.querySelectorAll(".nav-btn").forEach(btn => btn.classList.remove("active"));
            document.getElementById("nav-buscadores").classList.add("active");


          populateSearchEngineDropdown([]); // Populate dropdown with empty array
          populateEditTable([]); // Populate edit table with empty array
          console.log("initializeUI completado (sin datos)."); // Log exit
          return; // Exit if no data
      }

       // Ensure all sections are hidden before showing the active one
       document.querySelectorAll(".section").forEach(section => section.classList.add("hidden"));
       // Show the currently active section (default to buscadores if none active)
       const activeNavButton = document.querySelector(".nav-btn.active");
       const activeSectionId = activeNavButton ? activeNavButton.id.replace("nav-", "section-") : "section-buscadores";
       document.getElementById(activeSectionId).classList.remove("hidden");


      console.log("Llamando a renderSearchEngines..."); // Log before call
      renderSearchEngines(currentData.filter(item => item.type === 'Buscador'));
      console.log("Llamando a populateSearchEngineDropdown..."); // Log before call
      populateSearchEngineDropdown(currentData.filter(item => item.type === 'Buscador'));
      console.log("Llamando a renderLinks..."); // Log before call
      renderLinks(currentData.filter(item => item.type === 'Link'));
      console.log("Llamando a renderPrompts..."); // Log before call
      renderPrompts(currentData.filter(item => item.type === 'Promp'));
      console.log("Llamando a renderNotes..."); // Log before call
      renderNotes(currentData.filter(item => item.type === 'Nota')); // Render Notes
      console.log("Llamando a renderTasks..."); // Log before call
      renderTasks(currentData.filter(item => item.type === 'Tarea')); // Render Tasks
      console.log("Llamando a populateEditTable..."); // Log before call
      populateEditTable(currentData);

       // Hide "No items found" messages initially - these will be shown by filterItems if needed
       document.getElementById("noBuscadoresFound").classList.add("hidden");
       document.getElementById("noLinksFound").classList.add("hidden");
       document.getElementById("noPromptsFound").classList.add("hidden");
       document.getElementById("noNotesFound").classList.add("hidden");
       document.getElementById("noTasksFound").classList.add("hidden");


       console.log("initializeUI completado (con datos)."); // Log exit

        // Re-apply current filters after UI is initialized with data
        const currentlyActiveNavButton = document.querySelector(".nav-btn.active");
        if (currentlyActiveNavButton) {
            const sectionId = currentlyActiveNavButton.id.replace("nav-", "section-");
            const sectionSearchInputId = sectionId.replace('section-', '') + 'CardSearchInput';
            const searchTerm = document.getElementById(sectionSearchInputId)?.value.toLowerCase() || "";
            const sectionFilterButtonsId = sectionId.replace('section-', '') + 'FilterButtons';
            const activeFilterBtn = document.querySelector(`#${sectionFilterButtonsId} .filter-btn.active`);
            const category = activeFilterBtn ? activeFilterBtn.getAttribute("data-category") : "";
             const singularItemType = getSingularItemType(sectionId.replace('section-', ''));
             if (singularItemType) {
                filterItems(singularItemType, category, searchTerm);
             }
        } else {
            // If no nav button was active (shouldn't happen with default active class), filter the first section
             filterItems('Buscador', '', '');
        }
    }

    function setupNavigation() {
      console.log("Configurando navegación..."); // Log entry
      const navButtons = document.querySelectorAll(".nav-btn");
      const sections = document.querySelectorAll(".section");
      navButtons.forEach((btn) => {
        btn.addEventListener("click", function () {
          navButtons.forEach((b) => b.classList.remove("active"));
          sections.forEach((s) => s.classList.add("hidden"));
          this.classList.add("active");
          const sectionId = this.id.replace("nav-", "section-");
          document.getElementById(sectionId).classList.remove("hidden");

           // Trigger filter for the newly active section to apply any existing search term
           const activeSectionId = document.querySelector('.section:not(.hidden)').id;
           // Find the correct search input for the active section
           const sectionSearchInputId = activeSectionId.replace('section-', '') + 'CardSearchInput';
           const searchTerm = document.getElementById(sectionSearchInputId)?.value.toLowerCase() || "";

           // Find the active filter button for the active section
           const sectionFilterButtonsId = activeSectionId.replace('section-', '') + 'FilterButtons';
           const activeFilterBtn = document.querySelector(`#${sectionFilterButtonsId} .filter-btn.active`);
           const category = activeFilterBtn ? activeFilterBtn.getAttribute("data-category") : "";

           const sectionType = activeSectionId.replace('section-', ''); // e.g., 'buscadores', 'links'

           // Call a function to find the correct singular type from the plural section ID
           const singularItemType = getSingularItemType(sectionType);


           // Use a single filter function call with the correct type
           if (singularItemType) {
               filterItems(singularItemType, category, searchTerm);
           } else {
              console.error("No se pudo determinar el tipo de elemento para la sección:", sectionType);
           }
        });
      });
       console.log("Navegación configurada."); // Log exit
    }

     // Helper function to get singular item type from plural section ID
     function getSingularItemType(sectionType) {
         if (sectionType === 'buscadores') return 'Buscador';
         if (sectionType === 'links') return 'Link';
         if (sectionType === 'prompts') return 'Promp';
         if (sectionType === 'notes') return 'Nota';
         if (sectionType === 'tasks') return 'Tarea';
         return null; // Unknown type
     }


     // Centralized filter function
     function filterItems(itemType, category, searchTerm) {
         console.log(`Filtrando ${itemType}s por categoría "${category}" y término "${searchTerm}"`);

         // Filter data based on type, category, and search term
         const filteredItems = data.filter(item => item.type === itemType && // Match the exact singular type
             (category === "" || item.category === category) && // Filter by category
             (searchTerm === "" || // Filter by search term
                 (item.title && item.title.toLowerCase().includes(searchTerm)) ||
                 (item.action && item.action.toLowerCase().includes(searchTerm)) ||
                 (item.category && item.category.toLowerCase().includes(searchTerm))
             )
         );

         console.log(`${itemType}s filtrados:`, filteredItems.length, "items");

         // Update the correct container and "no items found" message based on itemType
         const containerId = itemType === 'Buscador' ? 'searchEnginesContainer' :
                             itemType === 'Link' ? 'linksContainer' :
                             itemType === 'Promp' ? 'promptsContainer' :
                             itemType === 'Nota' ? 'notesContainer' :
                             itemType === 'Tarea' ? 'tasksContainer' : null;

         const noItemsMessageId = itemType === 'Buscador' ? 'noBuscadoresFound' :
                                  itemType === 'Link' ? 'noLinksFound' :
                                  itemType === 'Promp' ? 'noPromptsFound' :
                                  itemType === 'Nota' ? 'noNotesFound' :
                                  itemType === 'Tarea' ? 'noTasksFound' : null;

         if (containerId && noItemsMessageId) {
             if (filteredItems.length === 0) {
                 document.getElementById(noItemsMessageId).classList.remove("hidden");
             } else {
                 document.getElementById(noItemsMessageId).classList.add("hidden");
             }

             // Call the specific render function for the type
             if (itemType === 'Buscador') renderSearchEngines(filteredItems);
             else if (itemType === 'Link') renderLinks(filteredItems);
             else if (itemType === 'Promp') renderPrompts(filteredItems);
             else if (itemType === 'Nota') renderNotes(filteredItems);
             else if (itemType === 'Tarea') renderTasks(filteredItems);
         } else {
             console.error("Tipo de elemento desconocido:", itemType);
         }
     }


    function setupEventListeners() { // data is now a global variable
      console.log("Configurando listeners de eventos..."); // Log entry

      // Add event listener to the search term button in Add New Item
     document.querySelector("#editPanel .search-term-button").addEventListener("click", function() {
         const inputId = this.dataset.inputId;
         const inputElement = document.getElementById(inputId);
         if (inputElement) {
             inputElement.value += "{search_term}";
             updateLivePreview(); // Update preview after inserting
         }
     });


      // Search input listeners for card filtering
      document.getElementById("searchCardSearchInput").addEventListener("input", function() { filterItems('Buscador', document.querySelector("#searchFilterButtons .filter-btn.active")?.getAttribute("data-category"), this.value.toLowerCase()); });
      document.getElementById("linkCardSearchInput").addEventListener("input", function() { filterItems('Link', document.querySelector("#linkFilterButtons .filter-btn.active")?.getAttribute("data-category"), this.value.toLowerCase()); });
      document.getElementById("promptCardSearchInput").addEventListener("input", function() { filterItems('Promp', document.querySelector("#promptFilterButtons .filter-btn.active")?.getAttribute("data-category"), this.value.toLowerCase()); });
       document.getElementById("noteCardSearchInput").addEventListener("input", function() { filterItems('Nota', document.querySelector("#noteFilterButtons .filter-btn.active")?.getAttribute("data-category"), this.value.toLowerCase()); });
       document.getElementById("taskCardSearchInput").addEventListener("input", function() { filterItems('Tarea', document.querySelector("#taskFilterButtons .filter-btn.active")?.getAttribute("data-category"), this.value.toLowerCase()); });


      // Main search button (only for web search)
      document.getElementById("searchButton").addEventListener("click", function () {
        const searchTerm = document.getElementById("searchInput").value.trim();
        if (searchTerm) {
          // Guardar en sugerencias
          if(!searchHistory.includes(searchTerm)){
            searchHistory.push(searchTerm);
            localStorage.setItem("searchHistory", JSON.stringify(searchHistory));
            updateSearchSuggestions();
          }
          const selectedEngine = document.getElementById("selectedEngine").textContent;
          const engine = data.find(
            (item) => item.title === selectedEngine && item.type === "Buscador"
          );
          if (engine) {
            const url = engine.action ? engine.action.replace("{search_term}", encodeURIComponent(searchTerm)) : null;
            if (url) {
               window.open(url, "_blank");
            } else {
               console.warn(`Acción de búsqueda no definida para "${selectedEngine}".`);
               showToast(`Acción de búsqueda no definida para "${selectedEngine}".`);
            }
          } else {
               console.warn(`Motor de búsqueda "${selectedEngine}" no encontrado.`);
               showToast(`Motor de búsqueda "${selectedEngine}" no encontrado.`);
          }
        } else {
             showToast("Por favor, ingresa un término de búsqueda.");
        }
      });

      // Main search input (only triggers web search on Enter)
      document.getElementById("searchInput").addEventListener("keypress", function (e) {
        if (e.key === "Enter") {
          document.getElementById("searchButton").click();
        }
      });

      document.getElementById("dropdownToggle").addEventListener("click", function () {
        document.getElementById("searchEngineDropdown").classList.toggle("hidden");
      });

      document.addEventListener("click", function (e) {
        const dropdown = document.getElementById("searchEngineDropdown");
        const toggle = document.getElementById("dropdownToggle");
        // Check if the click target is inside the dropdown or the toggle button
        if (!dropdown.contains(e.target) && !toggle.contains(e.target)) {
          dropdown.classList.add("hidden");
        }
      });

      // Open edit panel with the new main button
      document.getElementById("mainEditButton").addEventListener("click", function () {
        document.getElementById("editPanel").classList.remove("hidden");
         // Populate the edit table when opening the panel
         populateEditTable(data);
          // Ensure new item form is reset and preview updated
          document.getElementById("newTitle").value = "";
          document.getElementById("newAction").value = "";
          document.getElementById("newType").value = "Buscador"; // Default type
          document.getElementById("newCategory").value = "";
          document.getElementById("newIcon").value = "";
          updateLivePreview();
          toggleSearchTermButton(); // Ensure search term button visibility is correct for default type
      });

      // Close edit panel
      document.getElementById("closeEditButton").addEventListener("click", function () {
        document.getElementById("editPanel").classList.add("hidden");
      });

      document.getElementById("addItemButton").addEventListener("click", function () {
        const title = document.getElementById("newTitle").value.trim();
        const action = document.getElementById("newAction").value.trim();
        const type = document.getElementById("newType").value;
        const category = document.getElementById("newCategory").value.trim();
        const icon = document.getElementById("newIcon").value.trim();

        if (title && action && category) {
          const newItem = { title, action, type, category, icon, id: Date.now().toString() + Math.random() }; // Generate ID
           if (type === 'Tarea') {
               newItem.completed = false; // Add completed status for tasks
           }
          data.push(newItem);
          saveData(data);
          // populateEditTable(data); // populateEditTable is called within initializeUI
          initializeUI(data); // Re-render all sections
          showToast("Elemento agregado correctamente");
           // Close panel after adding? Or keep open? Keeping open for now.
           // document.getElementById("editPanel").classList.add("hidden");
        } else {
            showToast("Por favor, completa Título, Acción y Categoría.");
        }
      });

      // Export Data Button
      document.getElementById("exportDataButton").addEventListener("click", function() {
          exportData();
      });

      // Import Data Button
      document.getElementById("importDataButton").addEventListener("click", function() {
          document.getElementById("importDataInput").click(); // Trigger the file input click
      });

      // File input change listener for importing
      document.getElementById("importDataInput").addEventListener("change", function(event) {
          const file = event.target.files[0];
          if (file) {
              importData(file);
          }
      });

       // No need for saveChangesButton if using inline edit buttons in table
       // document.getElementById("saveChangesButton")?.addEventListener("click", function () { ... });

       console.log("Listeners de eventos configurados."); // Log exit
    }


    // --- Funciones de Renderizado Específicas ---


    function renderSearchEngines(engines) { // Receives filtered data
      console.log("Renderizando Buscadores:", engines.length, "items"); // Log entry
      const container = document.getElementById("searchEnginesContainer");
      container.innerHTML = "";
      const allEngines = data.filter(item => item.type === 'Buscador');
      // Use all engines for filter buttons, then sort categories
      const allCategories = [...new Set(allEngines.map((item) => item.category))];
      const sortedAllCategories = allCategories.sort(); // Sort all categories alphabetically
      const filterContainer = document.getElementById("searchFilterButtons");

      // Render filter buttons only if data is not empty
      if (allEngines.length > 0) {
           filterContainer.innerHTML = `<button class="filter-btn px-3 py-1 bg-gray-200 rounded-md text-sm filter-all" data-category="">Todos</button>`; // Add data-category="" for "Todos"
           sortedAllCategories.forEach((category) => {
             filterContainer.innerHTML += `<button class="filter-btn px-3 py-1 bg-gray-200 rounded-md text-sm" data-category="${category}">${category}</button>`;
           });
            // Re-attach event listeners to filter buttons after re-rendering them
            document.querySelectorAll("#searchFilterButtons .filter-btn").forEach((btn) => {
                btn.addEventListener("click", function () {
                    document.querySelectorAll("#searchFilterButtons .filter-btn").forEach((b) => b.classList.remove("active"));
                    this.classList.add("active");
                    const category = this.getAttribute("data-category");
                     // Call the centralized filter function
                    filterItems('Buscador', category, document.getElementById("searchCardSearchInput").value.toLowerCase());
                });
            });
            // Ensure the currently active filter button remains active after re-render
            const activeFilterBtn = document.querySelector("#searchFilterButtons .filter-btn.active");
            if (activeFilterBtn) {
                 const currentCategory = activeFilterBtn.getAttribute("data-category");
                 document.querySelector(`#searchFilterButtons .filter-btn[data-category="${currentCategory}"]`)?.classList.add('active');
            } else {
                 // Default to 'Todos' if no filter is active
                 document.querySelector("#searchFilterButtons .filter-btn.filter-all")?.classList.add('active');
            }


      } else {
         filterContainer.innerHTML = ''; // Clear filter buttons if no data
      }


      const categorizedEngines = {};
      engines.forEach((engine) => { // Use the filtered list for rendering
          const category = engine.category || 'Sin Categoría'; // Handle items without category
          if (!categorizedEngines[category]) categorizedEngines[category] = [];
          categorizedEngines[category].push(engine);
      });

      // Sort the categories that actually have items after filtering
      const categoriesWithItems = Object.keys(categorizedEngines).sort();

      //container.innerHTML = ""; // Clear existing content - already done at the start of the function

      categoriesWithItems.forEach((category) => {
          const categoryDiv = document.createElement("div");
          categoryDiv.className = "mb-8 col-span-full"; // Make category title span full width
          categoryDiv.innerHTML = `<h3 class="category-title text-xl font-semibold mb-4">${category}</h3>
              <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4 category-engines"></div>`;
          const categoryContainer = categoryDiv.querySelector(".category-engines");

          // Sort engines within each category by title
          categorizedEngines[category].sort((a, b) => a.title.localeCompare(b.title));

          categorizedEngines[category].forEach((engine) => {
              const engineCard = document.createElement("div");
              engineCard.className = "tooltip-container relative card bg-white p-4 rounded-lg text-center";
               engineCard.setAttribute("data-id", engine.id); // Add data-id attribute
               engineCard.setAttribute("data-type", engine.type); // Add data-type attribute
               addDragAndDropListeners(engineCard); // Add DnD listeners

              const iconHtml = getIconHtml(engine, false);

              // Display mode HTML
              const displayModeHtml = `
                 <div class="display-mode card-content">
                     <a href="${engine.action ? engine.action.replace("{search_term}", "") : '#'}" target="_blank" class="engine-link block" ${engine.action ? '' : 'onclick="return false;"'} style="pointer-events: auto;"> ${iconHtml}
                         <div class="mt-2 font-medium text-sm">${engine.title}</div>
                     </a>
                      <div class="mt-2">
                         <button class="edit-btn text-blue-600 text-xs mr-2">
                             <i class="fas fa-edit"></i> Editar
                         </button>
                         <button class="delete-btn text-red-600 text-xs">
                             <i class="fas fa-trash-alt"></i> Eliminar
                         </button>
                      </div>
                 </div>
              `;

              // Edit mode HTML
              const editModeHtml = `
                 <div class="edit-mode">
                     <label class="block text-sm font-medium mb-1">Título</label>
                     <input type="text" class="edit-title" value="${engine.title}">
                     <label class="block text-sm font-medium mb-1">Acción (URL)</label>
                      <div class="flex items-center">
                         <input type="text" class="edit-action w-full px-3 py-2 border border-gray-300 rounded-md" value="${engine.action || ''}">
                         <button class="search-term-button" data-input-class="edit-action">{search_term}</button>
                     </div>
                     <label class="block text-sm font-medium mb-1">Categoría</label>
                     <input type="text" class="edit-category" value="${engine.category}">
                     <label class="block text-sm font-medium mb-1">Icono (Clase FontAwesome)</label>
                     <input type="text" class="edit-icon" value="${engine.icon || ''}">
                     <div class="flex justify-center mt-2">
                         <button class="save-btn bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded-md text-xs mr-2"><i class="fas fa-save"></i> Guardar</button>
                         <button class="cancel-btn bg-gray-300 hover:bg-gray-400 text-gray-800 px-3 py-1 rounded-md text-xs"><i class="fas fa-times"></i> Cancelar</button>
                     </div>
                 </div>
              `;

              engineCard.innerHTML = displayModeHtml + editModeHtml + `<div class="tooltip">Arrastra para reordenar</div>`;

              // Add event listener for the edit button
              engineCard.querySelector(".edit-btn").addEventListener("click", function () {
                  engineCard.classList.add("editing");
                   // Show/hide search term button in inline edit
                  const searchTermButton = engineCard.querySelector(".search-term-button");
                  if (engine.type === "Buscador") {
                      searchTermButton.classList.remove("hidden");
                  } else {
                      searchTermButton.classList.add("hidden");
                  }
              });

               // Add event listener for the delete button
               engineCard.querySelector(".delete-btn").addEventListener("click", function () {
                 if (confirm("¿Estás seguro de que deseas eliminar este elemento?")) {
                   deleteItem(engine.id);
                 }
               });

              // Add event listener for the save button in edit mode
              engineCard.querySelector(".save-btn").addEventListener("click", function () {
                  const updatedTitle = engineCard.querySelector(".edit-title").value.trim();
                  const updatedAction = engineCard.querySelector(".edit-action").value.trim();
                  const updatedCategory = engineCard.querySelector(".edit-category").value.trim();
                  const updatedIcon = engineCard.querySelector(".edit-icon").value.trim();

                  if (updatedTitle && updatedAction && updatedCategory) {
                     updateItem(engine.id, {
                       title: updatedTitle,
                       action: updatedAction,
                       type: engine.type, // Type doesn't change with inline edit
                       category: updatedCategory,
                       icon: updatedIcon
                     });
                     engineCard.classList.remove("editing"); // Exit edit mode
                  } else {
                     showToast("Por favor, completa todos los campos.");
                  }
              });

               // Add event listener for the cancel button in edit mode
               engineCard.querySelector(".cancel-btn").addEventListener("click", function () {
                 engineCard.classList.remove("editing"); // Exit edit mode
                  // Revert input values (optional)
               });

               // Add event listener to the search term button in inline edit
               const searchTermButton = engineCard.querySelector(".search-term-button");
               if (searchTermButton) {
                   searchTermButton.addEventListener("click", function() {
                       const inputClass = this.dataset.inputClass;
                       const inputElement = engineCard.querySelector(`.${inputClass}`);
                       if (inputElement) {
                           inputElement.value += "{search_term}";
                       }
                   });
               }


              categoryContainer.appendChild(engineCard);
          });

           // Add "Agregar nuevo" card
           // Only add 'Add New' card if there are items of this type or the category is empty or no items are currently displayed due to filter
           const hasAnyEngine = data.some(item => item.type === 'Buscador');
           if (hasAnyEngine || engines.length === 0) { // Add card if there are *any* engines OR the current filtered list is empty (allowing adding to empty results)
           // Also check if the category being rendered exists in the list of categories from all engines, or if it's the 'Sin Categoría' special case.
           // This prevents adding "Sin Categoría" cards in categories that don't exist in the full data.
             const categoryExistsInAll = allCategories.includes(category) || category === 'Sin Categoría';

             if (categoryExistsInAll) {
                 const addCard = document.createElement("div");
                 addCard.className = "card bg-gray-100 p-4 rounded-lg flex flex-col items-center justify-center cursor-pointer";
                 addCard.innerHTML = `<i class="fas fa-plus text-3xl text-green-600 mb-2"></i><span class="text-sm text-green-600 text-center">Agregar nuevo</span>`;
                 addCard.addEventListener("click", function () {
                   document.getElementById("editPanel").classList.remove("hidden");
                   document.getElementById("newType").value = "Buscador"; // <-- This line sets the type
                   document.getElementById("newCategory").value = category === 'Sin Categoría' ? '' : category; // Pre-fill with the current category
                    updateLivePreview(); // Update preview for new item
                    toggleSearchTermButton(); // Ensure search term button is visible if type is Buscador
                 });
                 categoryContainer.appendChild(addCard);
             }
           }


          container.appendChild(categoryDiv);
      });
       console.log("Buscadores renderizados."); // Log exit
    }


    function populateSearchEngineDropdown(engines) { // Receives filtered data
       console.log("Poblando dropdown de buscadores..."); // Log entry
      const dropdown = document.getElementById("searchEngineDropdown");
      dropdown.innerHTML = "";
       // Sort engines alphabetically by title for the dropdown
       const sortedEngines = [...engines].sort((a, b) => (a.title || '').localeCompare(b.title || '')); // Handle potential null/undefined titles

      sortedEngines.forEach((engine) => {
        const item = document.createElement("div");
        item.className = "dropdown-item cursor-pointer hover:bg-gray-100";
        item.innerHTML = `${getIconHtml(engine, false)} <span>${engine.title}</span>`;
        item.addEventListener("click", function () {
          document.getElementById("selectedEngine").textContent = engine.title;
          document.getElementById("searchEngineDropdown").classList.add("hidden");
        });
        dropdown.appendChild(item);
      });
       console.log("Dropdown de buscadores poblado."); // Log exit
    }


    function renderLinks(links) { // Receives filtered data
      console.log("Renderizando Links:", links.length, "items"); // Log entry
      const container = document.getElementById("linksContainer");
      container.innerHTML = "";
      const allLinks = data.filter(item => item.type === 'Link');
      // Use all links for filter buttons, then sort categories
      const allCategories = [...new Set(allLinks.map((item) => item.category))];
      const sortedAllCategories = allCategories.sort();
      const filterContainer = document.getElementById("linkFilterButtons");

      // Render filter buttons only if data is not empty
       if (allLinks.length > 0) {
           filterContainer.innerHTML = `<button class="filter-btn px-3 py-1 bg-gray-200 rounded-md text-sm filter-all" data-category="">Todos</button>`; // Add data-category="" for "Todos"
           sortedAllCategories.forEach((category) => {
             filterContainer.innerHTML += `<button class="filter-btn px-3 py-1 bg-gray-200 rounded-md text-sm" data-category="${category}">${category}</button>`;
           });
            // Re-attach event listeners to filter buttons after re-rendering them
            document.querySelectorAll("#linkFilterButtons .filter-btn").forEach((btn) => {
                btn.addEventListener("click", function () {
                    document.querySelectorAll("#linkFilterButtons .filter-btn").forEach((b) => b.classList.remove("active"));
                    this.classList.add("active");
                    const category = this.getAttribute("data-category");
                     // Call the centralized filter function
                    filterItems('Link', category, document.getElementById("linkCardSearchInput").value.toLowerCase());
                });
            });
             // Ensure the currently active filter button remains active after re-render
            const activeFilterBtn = document.querySelector("#linkFilterButtons .filter-btn.active");
            if (activeFilterBtn) {
                 const currentCategory = activeFilterBtn.getAttribute("data-category");
                 document.querySelector(`#linkFilterButtons .filter-btn[data-category="${currentCategory}"]`)?.classList.add('active');
            } else {
                 // Default to 'Todos' if no filter is active
                 document.querySelector("#linkFilterButtons .filter-btn.filter-all")?.classList.add('active');
            }
       } else {
         filterContainer.innerHTML = ''; // Clear filter buttons if no data
       }


      const categorizedLinks = {};
      links.forEach((link) => { // Use the filtered list for rendering
         const category = link.category || 'Sin Categoría'; // Handle items without category
        if (!categorizedLinks[category]) categorizedLinks[category] = [];
        categorizedLinks[category].push(link);
      });
      //container.innerHTML = ""; // Clear existing content - already done at the start of the function
       // Sort categories alphabetically
      const sortedCategories = Object.keys(categorizedLinks).sort();

      sortedCategories.forEach((category) => {
        const categoryDiv = document.createElement("div");
        categoryDiv.className = "mb-8 col-span-full"; // Span full width for links
        categoryDiv.innerHTML = `<h3 class="category-title text-xl font-semibold mb-4">${category}</h3>
            <div class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-4 category-links"></div>`;
        const categoryContainer = categoryDiv.querySelector(".category-links");

         // Sort links within each category by title
         categorizedLinks[category].sort((a, b) => (a.title || '').localeCompare(b.title || ''));

        categorizedLinks[category].forEach((link) => {
          const linkCard = document.createElement("div");
          linkCard.className = "tooltip-container relative card bg-white p-4 rounded-lg";
          linkCard.setAttribute("data-id", link.id); // Add data-id attribute
           linkCard.setAttribute("data-type", link.type); // Add data-type attribute
          addDragAndDropListeners(linkCard);
          const iconHtml = getIconHtml(link, false);

          // Display mode HTML
          const displayModeHtml = `
            <div class="display-mode card-content">
              <a href="${link.action || '#'}" target="_blank" class="link-btn block text-center" ${link.action ? '' : 'onclick="return false;"'} style="pointer-events: auto;"> ${iconHtml}
                <div class="mt-2 font-medium text-sm">${link.title}</div>
              </a>
               <div class="mt-2">
                 <button class="edit-btn text-blue-600 text-xs mr-2">
                   <i class="fas fa-edit"></i> Editar
                 </button>
                 <button class="delete-btn text-red-600 text-xs">
                   <i class="fas fa-trash-alt"></i> Eliminar
                 </button>
               </div>
            </div>
          `;

           // Edit mode HTML
          const editModeHtml = `
            <div class="edit-mode text-center">
              <label class="block text-sm font-medium mb-1">Título</label>
              <input type="text" class="edit-title" value="${link.title}">
              <label class="block text-sm font-medium mb-1">Acción (URL)</label>
              <input type="text" class="edit-action" value="${link.action || ''}">
               <label class="block text-sm font-medium mb-1">Categoría</label>
              <input type="text" class="edit-category" value="${link.category}">
              <label class="block text-sm font-medium mb-1">Icono (Clase FontAwesome)</label>
              <input type="text" class="edit-icon" value="${link.icon || ''}">
              <div class="flex justify-center mt-2">
                <button class="save-btn bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded-md text-xs mr-2"><i class="fas fa-save"></i> Guardar</button>
                <button class="cancel-btn bg-gray-300 hover:bg-gray-400 text-gray-800 px-3 py-1 rounded-md text-xs"><i class="fas fa-times"></i> Cancelar</button>
              </div>
            </div>
          `;

          linkCard.innerHTML = displayModeHtml + editModeHtml + `<div class="tooltip">Arrastra para reordenar</div>`;

          // Add event listener for the edit button
          linkCard.querySelector(".edit-btn").addEventListener("click", function () {
            linkCard.classList.add("editing");
          });

           // Add event listener for the delete button
           linkCard.querySelector(".delete-btn").addEventListener("click", function () {
             if (confirm("¿Estás seguro de que deseas eliminar este elemento?")) {
               deleteItem(link.id);
             }
           });

          // Add event listener for the save button in edit mode
          linkCard.querySelector(".save-btn").addEventListener("click", function () {
            const updatedTitle = linkCard.querySelector(".edit-title").value.trim();
            const updatedAction = linkCard.querySelector(".edit-action").value.trim();
            const updatedCategory = linkCard.querySelector(".edit-category").value.trim();
            const updatedIcon = linkCard.querySelector(".edit-icon").value.trim();

             if (updatedTitle && updatedAction && updatedCategory) {
                updateItem(link.id, {
                  title: updatedTitle,
                  action: updatedAction,
                  type: link.type, // Type doesn't change with inline edit
                  category: updatedCategory,
                  icon: updatedIcon
                });
                linkCard.classList.remove("editing"); // Exit edit mode
             } else {
                showToast("Por favor, completa todos los campos.");
             }
          });

          // Add event listener for the cancel button in edit mode
          linkCard.querySelector(".cancel-btn").addEventListener("click", function () {
            linkCard.classList.remove("editing"); // Exit edit mode
             // Revert input values (optional)
          });

          categoryContainer.appendChild(linkCard);
        });

        // Tarjeta para agregar nuevo enlace en esta categoría
         // Only add 'Add New' card if there are items of this type or the category is empty or no items are currently displayed due to filter
        const hasAnyLink = data.some(item => item.type === 'Link');
        if (hasAnyLink || links.length === 0) {
             const categoryExistsInAll = allCategories.includes(category) || category === 'Sin Categoría';
             if (categoryExistsInAll) {
                 const addCard = document.createElement("div");
                 addCard.className = "card bg-gray-100 p-4 rounded-lg flex flex-col items-center justify-center cursor-pointer";
                 addCard.innerHTML = `<i class="fas fa-plus text-3xl text-green-600 mb-2"></i><span class="text-sm text-green-600 text-center">Agregar nuevo</span>`;
                 addCard.addEventListener("click", function () {
                   document.getElementById("editPanel").classList.remove("hidden");
                    // Optionally pre-fill the category field
                   document.getElementById("newType").value = "Link"; // <-- This line sets the type
                   document.getElementById("newCategory").value = category === 'Sin Categoría' ? '' : category;
                    updateLivePreview(); // Update preview for new item
                     toggleSearchTermButton(); // Ensure search term button is hidden for Link type
                 });
                 categoryContainer.appendChild(addCard);
             }
         }
        container.appendChild(categoryDiv);
      });
       console.log("Links renderizados."); // Log exit
    }


    function renderPrompts(prompts) { // Receives filtered data
      console.log("Renderizando Prompts:", prompts.length, "items"); // Log entry
      const container = document.getElementById("promptsContainer");
      container.innerHTML = "";
      const allPrompts = data.filter(item => item.type === 'Promp');
      // Use all prompts for filter buttons, then sort categories
      const allCategories = [...new Set(allPrompts.map((item) => item.category))];
      const sortedAllCategories = allCategories.sort();
      const filterContainer = document.getElementById("promptFilterButtons");

       // Render filter buttons only if data is not empty
       if (allPrompts.length > 0) {
           filterContainer.innerHTML = `<button class="filter-btn px-3 py-1 bg-gray-200 rounded-md text-sm filter-all" data-category="">Todos</button>`; // Add data-category="" for "Todos"
           sortedAllCategories.forEach((category) => {
             filterContainer.innerHTML += `<button class="filter-btn px-3 py-1 bg-gray-200 rounded-md text-sm" data-category="${category}">${category}</button>`;
           });
            // Re-attach event listeners to filter buttons after re-rendering them
            document.querySelectorAll("#promptFilterButtons .filter-btn").forEach((btn) => {
                btn.addEventListener("click", function () {
                    document.querySelectorAll("#promptFilterButtons .filter-btn").forEach((b) => b.classList.remove("active"));
                    this.classList.add("active");
                    const category = this.getAttribute("data-category");
                     // Call the centralized filter function
                    filterItems('Promp', category, document.getElementById("promptCardSearchInput").value.toLowerCase());
                });
            });
             // Ensure the currently active filter button remains active after re-render
            const activeFilterBtn = document.querySelector("#promptFilterButtons .filter-btn.active");
            if (activeFilterBtn) {
                 const currentCategory = activeFilterBtn.getAttribute("data-category");
                 document.querySelector(`#promptFilterButtons .filter-btn[data-category="${currentCategory}"]`)?.classList.add('active');
            } else {
                 // Default to 'Todos' if no filter is active
                 document.querySelector("#promptFilterButtons .filter-btn.filter-all")?.classList.add('active');
            }
       } else {
         filterContainer.innerHTML = ''; // Clear filter buttons if no data
       }


      const categorizedPrompts = {};
      prompts.forEach((prompt) => { // Use the filtered list for rendering
         const category = prompt.category || 'Sin Categoría'; // Handle items without category
        if (!categorizedPrompts[category]) categorizedPrompts[category] = [];
        categorizedPrompts[category].push(prompt);
      });

       // Sort categories alphabetically
       const sortedCategories = Object.keys(categorizedPrompts).sort();


      sortedCategories.forEach((category) => {
          const categoryDiv = document.createElement("div");
          categoryDiv.className = "mb-8 col-span-full"; // Span full width for prompts grid
          categoryDiv.innerHTML = `<h3 class="category-title text-xl font-semibold mb-4">${category}</h3>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 category-prompts"></div>`;
          const categoryContainer = categoryDiv.querySelector(".category-prompts");

           // Sort prompts within each category by title
           categorizedPrompts[category].sort((a, b) => (a.title || '').localeCompare(b.title || ''));

          categorizedPrompts[category].forEach((prompt) => {
            const promptCard = document.createElement("div");
            promptCard.className = "card bg-white p-4 rounded-lg tooltip-container prompt-card";
            promptCard.setAttribute("data-id", prompt.id); // Add data-id attribute
            promptCard.setAttribute("data-type", prompt.type); // Add data-type attribute
            promptCard.setAttribute("data-category", prompt.category);
            addDragAndDropListeners(promptCard);
            const iconHtml = getIconHtml(prompt, true);

            // Display mode HTML
            const displayModeHtml = `
              <div class="display-mode card-content">
                <div class="flex items-center justify-between">
                  <div class="flex items-center">
                    ${iconHtml}
                    <h4 class="text-lg font-medium ml-2">${prompt.title}</h4>
                  </div>
                  <span class="bg-purple-100 text-purple-800 text-xs px-2 py-1 rounded-full">${prompt.category}</span>
                </div>
                <div class="mt-3 bg-gray-50 p-2 rounded text-sm text-gray-700 prompt-content no-scrollbar">
                  ${prompt.action ? prompt.action.replace(/\n/g, "<br>") : ''}
                </div>
                <button class="copy-prompt-btn mt-3 w-full bg-purple-100 hover:bg-purple-200 text-purple-800 py-2 rounded-md text-sm font-medium">
                  <i class="far fa-copy mr-1"></i> Copiar al portapapeles
                </button>
                 <div class="mt-2">
                   <button class="edit-btn text-blue-600 text-xs mr-2">
                     <i class="fas fa-edit"></i> Editar
                   </button>
                   <button class="delete-btn text-red-600 text-xs">
                     <i class="fas fa-trash-alt"></i> Eliminar
                   </button>
                 </div>
              </div>
            `;

            // Edit mode HTML
            const editModeHtml = `
              <div class="edit-mode">
                <label class="block text-sm font-medium mb-1">Título</label>
                <input type="text" class="edit-title" value="${prompt.title}">
                <label class="block text-sm font-medium mb-1">Acción (Prompt)</label>
                <textarea class="edit-action w-full h-32">${prompt.action || ''}</textarea>
                <label class="block text-sm font-medium mb-1">Categoría</label>
                <input type="text" class="edit-category" value="${prompt.category}">
                <label class="block text-sm font-medium mb-1">Icono (Clase FontAwesome)</label>
                <input type="text" class="edit-icon" value="${prompt.icon || ''}">
                <div class="flex justify-end mt-2">
                  <button class="save-btn bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded-md text-xs mr-2"><i class="fas fa-save"></i> Guardar</button>
                  <button class="cancel-btn bg-gray-300 hover:bg-gray-400 text-gray-800 px-3 py-1 rounded-md text-xs"><i class="fas fa-times"></i> Cancelar</button>
                </div>
              </div>
            `;

            promptCard.innerHTML = displayModeHtml + editModeHtml + `<div class="tooltip">Arrastra para reordenar</div>`;

            promptCard.querySelector(".copy-prompt-btn").addEventListener("click", function () {
              navigator.clipboard.writeText(prompt.action).then(() => {
                showToast("Prompt copiado al portapapeles");
              }).catch(err => {
                 console.error("Error al copiar prompt:", err);
                 showToast("Error al copiar prompt.");
              });
            });

            // Add event listener for the edit button
            promptCard.querySelector(".edit-btn").addEventListener("click", function () {
              promptCard.classList.add("editing");
               // Hide search term button for Prompt type
               const searchTermButton = promptCard.querySelector(".search-term-button");
               if (searchTermButton) searchTermButton.classList.add("hidden");
            });

            // Add event listener for the delete button
            promptCard.querySelector(".delete-btn").addEventListener("click", function () {
              if (confirm("¿Estás seguro de que deseas eliminar este elemento?")) {
                deleteItem(prompt.id);
              }
            });

            // Add event listener for the save button in edit mode
            promptCard.querySelector(".save-btn").addEventListener("click", function () {
              const updatedTitle = promptCard.querySelector(".edit-title").value.trim();
              const updatedAction = promptCard.querySelector(".edit-action").value.trim();
              const updatedCategory = promptCard.querySelector(".edit-category").value.trim();
              const updatedIcon = promptCard.querySelector(".edit-icon").value.trim();

              if (updatedTitle && updatedAction && updatedCategory) {
                updateItem(prompt.id, {
                  title: updatedTitle,
                  action: updatedAction,
                  type: prompt.type, // Type doesn't change with inline edit
                  category: updatedCategory,
                  icon: updatedIcon
                });
                promptCard.classList.remove("editing"); // Exit edit mode
              } else {
                 showToast("Por favor, completa todos los campos.");
              }
            });

            // Add event listener for the cancel button in edit mode
            promptCard.querySelector(".cancel-btn").addEventListener("click", function () {
              promptCard.classList.remove("editing"); // Exit edit mode
              // Revert input values (optional)
            });

            categoryContainer.appendChild(promptCard);
          });

          // Tarjeta para agregar nuevo prompt en esta categoría
           // Only add 'Add New' card if there are items of this type or the category is empty or no items are currently displayed due to filter
          const hasAnyPrompt = data.some(item => item.type === 'Promp');
          if (hasAnyPrompt || prompts.length === 0) {
             const categoryExistsInAll = allCategories.includes(category) || category === 'Sin Categoría';
             if (categoryExistsInAll) {
                 const addCard = document.createElement("div");
                 addCard.className = "card bg-gray-100 p-4 rounded-lg flex flex-col items-center justify-center cursor-pointer";
                 addCard.innerHTML = `<i class="fas fa-plus text-3xl text-green-600 mb-2"></i><span class="text-sm text-green-600 text-center">Agregar nuevo</span>`;
                 addCard.addEventListener("click", function () {
                   document.getElementById("editPanel").classList.remove("hidden");
                    // Optionally pre-fill the category field
                   document.getElementById("newType").value = "Promp"; // <-- This line sets the type
                   document.getElementById("newCategory").value = category === 'Sin Categoría' ? '' : category;
                    updateLivePreview(); // Update preview for new item
                    toggleSearchTermButton(); // Ensure search term button is hidden for Prompt type
                 });
                 categoryContainer.appendChild(addCard);
             }
           }
          container.appendChild(categoryDiv);
      });
       console.log("Prompts renderizados."); // Log exit
    }


    function renderNotes(notes) { // Receives filtered data
        console.log("Renderizando Notas:", notes.length, "items"); // Log entry
        const container = document.getElementById("notesContainer");
        container.innerHTML = "";
        const allNotes = data.filter(item => item.type === 'Nota');
        // Use all notes for filter buttons, then sort categories
        const allCategories = [...new Set(allNotes.map((item) => item.category))];
        const sortedAllCategories = allCategories.sort();
        const filterContainer = document.getElementById("noteFilterButtons");

         // Render filter buttons only if data is not empty
        if (allNotes.length > 0) {
            filterContainer.innerHTML = `<button class="filter-btn px-3 py-1 bg-gray-200 rounded-md text-sm filter-all" data-category="">Todos</button>`;
            sortedAllCategories.forEach((category) => {
                filterContainer.innerHTML += `<button class="filter-btn px-3 py-1 bg-gray-200 rounded-md text-sm" data-category="${category}">${category}</button>`;
            });
             // Re-attach event listeners to filter buttons after re-rendering them
             document.querySelectorAll("#noteFilterButtons .filter-btn").forEach((btn) => {
                 btn.addEventListener("click", function () {
                     document.querySelectorAll("#noteFilterButtons .filter-btn").forEach((b) => b.classList.remove("active"));
                     this.classList.add("active");
                     const category = this.getAttribute("data-category");
                      // Call the centralized filter function
                     filterItems('Nota', category, document.getElementById("noteCardSearchInput").value.toLowerCase());
                 });
             });
              // Ensure the currently active filter button remains active after re-render
             const activeFilterBtn = document.querySelector("#noteFilterButtons .filter-btn.active");
             if (activeFilterBtn) {
                  const currentCategory = activeFilterBtn.getAttribute("data-category");
                  document.querySelector(`#noteFilterButtons .filter-btn[data-category="${currentCategory}"]`)?.classList.add('active');
             } else {
                  // Default to 'Todos' if no filter is active
                  document.querySelector("#noteFilterButtons .filter-btn.filter-all")?.classList.add('active');
             }
        } else {
           filterContainer.innerHTML = ''; // Clear filter buttons if no data
        }


        const categorizedNotes = {};
        notes.forEach((note) => { // Use the filtered list for rendering
          const category = note.category || 'Sin Categoría'; // Handle items without category
          if (!categorizedNotes[category]) categorizedNotes[category] = [];
          categorizedNotes[category].push(note);
        });

         // Sort categories alphabetically
        const sortedCategories = Object.keys(categorizedNotes).sort();

        sortedCategories.forEach((category) => {
            const categoryDiv = document.createElement("div");
            categoryDiv.className = "mb-8 col-span-full"; // Span full width for notes grid
            categoryDiv.innerHTML = `<h3 class="category-title text-xl font-semibold mb-4">${category}</h3>
              <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 category-notes"></div>`;
            const categoryContainer = categoryDiv.querySelector(".category-notes");

             // Sort notes within each category by title
             categorizedNotes[category].sort((a, b) => (a.title || '').localeCompare(b.title || ''));

            categorizedNotes[category].forEach((note) => {
                const noteCard = document.createElement("div");
                noteCard.className = "card bg-white p-4 rounded-lg tooltip-container note-card";
                noteCard.setAttribute("data-id", note.id);
                 noteCard.setAttribute("data-type", note.type);
                noteCard.setAttribute("data-category", note.category);
                addDragAndDropListeners(noteCard);
                const iconHtml = getIconHtml(note, false);

                const displayModeHtml = `
                  <div class="display-mode card-content">
                    <div class="flex items-center justify-between">
                      <div class="flex items-center">
                        ${iconHtml}
                        <h4 class="text-lg font-medium ml-2">${note.title}</h4>
                      </div>
                       <span class="bg-yellow-100 text-yellow-800 text-xs px-2 py-1 rounded-full">${note.category}</span>
                    </div>
                    <div class="mt-3 bg-gray-50 p-2 rounded text-sm text-gray-700 note-content no-scrollbar">
                      ${note.action ? note.action.replace(/\n/g, "<br>") : ''}
                    </div>
                     <div class="mt-2">
                       <button class="edit-btn text-blue-600 text-xs mr-2">
                         <i class="fas fa-edit"></i> Editar
                       </button>
                       <button class="delete-btn text-red-600 text-xs">
                         <i class="fas fa-trash-alt"></i> Eliminar
                       </button>
                     </div>
                  </div>
                `;

                 const editModeHtml = `
                   <div class="edit-mode">
                     <label class="block text-sm font-medium mb-1">Título</label>
                     <input type="text" class="edit-title" value="${note.title}">
                     <label class="block text-sm font-medium mb-1">Contenido</label>
                     <textarea class="edit-action w-full h-32">${note.action || ''}</textarea>
                     <label class="block text-sm font-medium mb-1">Categoría</label>
                     <input type="text" class="edit-category" value="${note.category}">
                     <label class="block text-sm font-medium mb-1">Icono (Clase FontAwesome)</label>
                     <input type="text" class="edit-icon" value="${note.icon || ''}">
                     <div class="flex justify-end mt-2">
                       <button class="save-btn bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded-md text-xs mr-2"><i class="fas fa-save"></i> Guardar</button>
                       <button class="cancel-btn bg-gray-300 hover:bg-gray-400 text-gray-800 px-3 py-1 rounded-md text-xs"><i class="fas fa-times"></i> Cancelar</button>
                     </div>
                   </div>
                 `;

                noteCard.innerHTML = displayModeHtml + editModeHtml + `<div class="tooltip">Arrastra para reordenar</div>`;

                noteCard.querySelector(".edit-btn").addEventListener("click", function () {
                    noteCard.classList.add("editing");
                     // Hide search term button for Note type
                    const searchTermButton = noteCard.querySelector(".search-term-button");
                    if (searchTermButton) searchTermButton.classList.add("hidden");
                });

                noteCard.querySelector(".delete-btn").addEventListener("click", function () {
                    if (confirm("¿Estás seguro de que deseas eliminar esta nota?")) {
                        deleteItem(note.id);
                    }
                });

                noteCard.querySelector(".save-btn").addEventListener("click", function () {
                    const updatedTitle = noteCard.querySelector(".edit-title").value.trim();
                    const updatedAction = noteCard.querySelector(".edit-action").value.trim();
                    const updatedCategory = noteCard.querySelector(".edit-category").value.trim();
                    const updatedIcon = noteCard.querySelector(".edit-icon").value.trim();

                    if (updatedTitle && updatedAction && updatedCategory) {
                       updateItem(note.id, {
                         title: updatedTitle,
                         action: updatedAction,
                         type: note.type,
                         category: updatedCategory,
                         icon: updatedIcon
                       });
                       noteCard.classList.remove("editing");
                    } else {
                       showToast("Por favor, completa todos los campos.");
                    }
                });

                noteCard.querySelector(".cancel-btn").addEventListener("click", function () {
                    noteCard.classList.remove("editing");
                });

                categoryContainer.appendChild(noteCard);
            });

             // Add "Agregar nuevo" card
             // Only add 'Add New' card if there are items of this type or the category is empty or no items are currently displayed due to filter
            const hasAnyNote = data.some(item => item.type === 'Nota');
            if (hasAnyNote || notes.length === 0) {
             const categoryExistsInAll = allCategories.includes(category) || category === 'Sin Categoría';
             if (categoryExistsInAll) {
                   const addCard = document.createElement("div");
                   addCard.className = "card bg-gray-100 p-4 rounded-lg flex flex-col items-center justify-center cursor-pointer";
                   addCard.innerHTML = `<i class="fas fa-plus text-3xl text-green-600 mb-2"></i><span class="text-sm text-green-600 text-center">Agregar nuevo</span>`;
                   addCard.addEventListener("click", function () {
                     document.getElementById("editPanel").classList.remove("hidden");
                     document.getElementById("newType").value = "Nota"; // <-- This line sets the type
                     document.getElementById("newCategory").value = category === 'Sin Categoría' ? '' : category; // Pre-fill with the current category
                      updateLivePreview(); // Update preview for new item
                      toggleSearchTermButton(); // Ensure search term button is hidden for Note type
                   });
                   categoryContainer.appendChild(addCard);
             }
            }

            container.appendChild(categoryDiv);
        });
         console.log("Notas renderizadas."); // Log exit
    }


     function renderTasks(tasks) { // Receives filtered data
         console.log("Renderizando Tareas:", tasks.length, "items"); // Log entry
         const container = document.getElementById("tasksContainer");
         container.innerHTML = "";
         const allTasks = data.filter(item => item.type === 'Tarea');
         // Use all tasks for filter buttons, then sort categories
         const allCategories = [...new Set(allTasks.map((item) => item.category))];
         const sortedAllCategories = allCategories.sort();
         const filterContainer = document.getElementById("taskFilterButtons");

          // Render filter buttons only if data is not empty
         if (allTasks.length > 0) {
             filterContainer.innerHTML = `<button class="filter-btn px-3 py-1 bg-gray-200 rounded-md text-sm filter-all" data-category="">Todos</button>`;
             sortedAllCategories.forEach((category) => {
                 filterContainer.innerHTML += `<button class="filter-btn px-3 py-1 bg-gray-200 rounded-md text-sm" data-category="${category}">${category}</button>`;
             });
              // Re-attach event listeners to filter buttons after re-rendering them
              document.querySelectorAll("#taskFilterButtons .filter-btn").forEach((btn) => {
                  btn.addEventListener("click", function () {
                      document.querySelectorAll("#taskFilterButtons .filter-btn").forEach((b) => b.classList.remove("active"));
                      this.classList.add("active");
                      const category = this.getAttribute("data-category");
                       // Call the centralized filter function
                      filterItems('Tarea', category, document.getElementById("taskCardSearchInput").value.toLowerCase());
                  });
              });
               // Ensure the currently active filter button remains active after re-render
              const activeFilterBtn = document.querySelector("#taskFilterButtons .filter-btn.active");
              if (activeFilterBtn) {
                   const currentCategory = activeFilterBtn.getAttribute("data-category");
                   document.querySelector(`#taskFilterButtons .filter-btn[data-category="${currentCategory}"]`)?.classList.add('active');
              } else {
                   // Default to 'Todos' if no filter is active
                   document.querySelector("#taskFilterButtons .filter-btn.filter-all")?.classList.add('active');
              }
         } else {
            filterContainer.innerHTML = ''; // Clear filter buttons if no data
         }


         const categorizedTasks = {};
         tasks.forEach((task) => { // Use the filtered list for rendering
           const category = task.category || 'Sin Categoría'; // Handle items without category
           if (!categorizedTasks[category]) categorizedTasks[category] = [];
           categorizedTasks[category].push(task);
         });

          // Sort categories alphabetically
         const sortedCategories = Object.keys(categorizedTasks).sort();

         sortedCategories.forEach((category) => {
             const categoryDiv = document.createElement("div");
             categoryDiv.className = "mb-8 col-span-full"; // Span full width for tasks grid
             categoryDiv.innerHTML = `<h3 class="category-title text-xl font-semibold mb-4">${category}</h3>
               <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 category-tasks"></div>`;
             const categoryContainer = categoryDiv.querySelector(".category-tasks");

              // Sort tasks within each category by title
              categorizedTasks[category].sort((a, b) => (a.title || '').localeCompare(b.title || ''));

             categorizedTasks[category].forEach((task) => {
                 const taskCard = document.createElement("div");
                 taskCard.className = `card bg-white p-4 rounded-lg tooltip-container task-card ${task.completed ? 'completed' : ''}`;
                 taskCard.setAttribute("data-id", task.id);
                 taskCard.setAttribute("data-type", task.type);
                 taskCard.setAttribute("data-category", task.category);
                 addDragAndDropListeners(taskCard);
                 const iconHtml = getIconHtml(task, false);

                 // Split action into lines and format as a list with interactive checkboxes
                 const taskLines = task.action.split('\n').filter(line => line.trim() !== '');
                 let taskListHtml = '<ul class="task-list">';
                 taskLines.forEach((line, index) => {
                     // Check if the line starts with "[x]" or "[ ]" to determine initial checked state
                     const isChecked = line.trim().startsWith('[x]');
                     const cleanedLine = line.replace(/^\[[x ]\]\s*/, '').trim(); // Remove "[x] " or "[ ] "
                     taskListHtml += `<li><input type="checkbox" class="task-list-checkbox" data-item-index="${index}" ${isChecked ? 'checked' : ''}> ${cleanedLine}</li>`;
                 });
                 taskListHtml += '</ul>';


                 const displayModeHtml = `
                   <div class="display-mode card-content">
                     <div class="flex items-center justify-between">
                       <div class="flex items-center">
                         <input type="checkbox" class="task-checkbox mr-2" ${task.completed ? 'checked' : ''} style="pointer-events: auto;"> <h4 class="text-lg font-medium">${task.title}</h4>
                       </div>
                        <span class="bg-teal-100 text-teal-800 text-xs px-2 py-1 rounded-full">${task.category}</span>
                     </div>
                     <div class="mt-3 bg-gray-50 p-2 rounded text-sm text-gray-700 task-content no-scrollbar">
                       ${taskListHtml}
                     </div>
                      <div class="mt-2">
                        <button class="edit-btn text-blue-600 text-xs mr-2">
                          <i class="fas fa-edit"></i> Editar
                        </button>
                        <button class="delete-btn text-red-600 text-xs">
                          <i class="fas fa-trash-alt"></i> Eliminar
                        </button>
                      </div>
                   </div>
                 `;

                  const editModeHtml = `
                    <div class="edit-mode">
                      <label class="block text-sm font-medium mb-1">Título</label>
                      <input type="text" class="edit-title" value="${task.title}">
                      <label class="block text-sm font-medium mb-1">Descripción (una línea por item de lista - usa [ ] o [x] al inicio)</label>
                      <textarea class="edit-action w-full h-32">${task.action || ''}</textarea>
                      <label class="block text-sm font-medium mb-1">Categoría</label>
                      <input type="text" class="edit-category" value="${task.category}">
                      <label class="block text-sm font-medium mb-1">Icono (Clase FontAwesome)</label>
                      <input type="text" class="edit-icon" value="${task.icon || ''}">
                       <div class="flex items-center mt-2">
                           <input type="checkbox" class="edit-completed mr-2" ${task.completed ? 'checked' : ''}>
                           <label class="text-sm font-medium">Completada (Marca la tarea completa)</label>
                       </div>
                      <div class="flex justify-end mt-2">
                        <button class="save-btn bg-green-600 hover:bg-green-700 text-white px-3 py-1 rounded-md text-xs mr-2"><i class="fas fa-save"></i> Guardar</button>
                        <button class="cancel-btn bg-gray-300 hover:bg-gray-400 text-gray-800 px-3 py-1 rounded-md text-xs"><i class="fas fa-times"></i> Cancelar</button>
                      </div>
                    </div>
                  `;

                 taskCard.innerHTML = displayModeHtml + editModeHtml + `<div class="tooltip">Arrastra para reordenar</div>`;

                 // Add event listener for the main task checkbox (marks the whole task complete)
                 taskCard.querySelector(".task-checkbox").addEventListener("change", function () {
                     const itemId = taskCard.dataset.id;
                     const isCompleted = this.checked;
                     updateItem(itemId, { completed: isCompleted }); // Update item and save
                 });

                  // Add event listeners for the individual list item checkboxes
                  // Note: Changes to these are NOT saved in the current data structure (action is a single string).
                  // They are visual-only for now. To save this, the 'action' would need to be structured data (e.g., array of objects with text and completed status).
                  taskCard.querySelectorAll(".task-list-checkbox").forEach(checkbox => {
                      checkbox.addEventListener("change", function() {
                          const listItem = this.closest("li");
                          if (this.checked) {
                              listItem.classList.add("completed");
                          } else {
                              listItem.classList.remove("completed");
                          }
                           // Optional: Visually update the main task checkbox if all sub-tasks are checked
                           // const allChecked = Array.from(taskCard.querySelectorAll(".task-list-checkbox")).every(cb => cb.checked);
                           // taskCard.querySelector(".task-checkbox").checked = allChecked;
                           // updateItem(taskCard.dataset.id, { completed: allChecked }); // This would save the main status based on sub-tasks
                      });
                  });


                 taskCard.querySelector(".edit-btn").addEventListener("click", function () {
                     taskCard.classList.add("editing");
                      // Hide search term button for Task type
                     const searchTermButton = taskCard.querySelector(".search-term-button");
                     if (searchTermButton) searchTermButton.classList.add("hidden");
                 });

                 taskCard.querySelector(".delete-btn").addEventListener("click", function () {
                     if (confirm("¿Estás seguro de que deseas eliminar esta tarea?")) {
                         deleteItem(task.id);
                     }
                 });

                 taskCard.querySelector(".save-btn").addEventListener("click", function () {
                     const updatedTitle = taskCard.querySelector(".edit-title").value.trim();
                     const updatedAction = taskCard.querySelector(".edit-action").value.trim(); // Get the text from the textarea
                     const updatedCategory = taskCard.querySelector(".edit-category").value.trim();
                     const updatedIcon = taskCard.querySelector(".edit-icon").value.trim();
                     const updatedCompleted = taskCard.querySelector(".edit-completed").checked;


                     if (updatedTitle && updatedAction && updatedCategory) {
                        updateItem(task.id, {
                          title: updatedTitle,
                          action: updatedAction, // Save the raw text from the textarea
                          type: task.type,
                          category: updatedCategory,
                          icon: updatedIcon,
                          completed: updatedCompleted
                        });
                        taskCard.classList.remove("editing");
                     } else {
                        showToast("Por favor, completa todos los campos.");
                     }
                 });

                 taskCard.querySelector(".cancel-btn").addEventListener("click", function () {
                     taskCard.classList.remove("editing");
                 });

                 categoryContainer.appendChild(taskCard);
             });

              // Add "Agregar nuevo" card
              // Only add 'Add New' card if there are items of this type or the category is empty or no items are currently displayed due to filter
             const hasAnyTask = data.some(item => item.type === 'Tarea');
             if (hasAnyTask || tasks.length === 0) {
                 const categoryExistsInAll = allCategories.includes(category) || category === 'Sin Categoría';
                 if (categoryExistsInAll) {
                   const addCard = document.createElement("div");
                   addCard.className = "card bg-gray-100 p-4 rounded-lg flex flex-col items-center justify-center cursor-pointer";
                   addCard.innerHTML = `<i class="fas fa-plus text-3xl text-green-600 mb-2"></i><span class="text-sm text-green-600 text-center">Agregar nuevo</span>`;
                   addCard.addEventListener("click", function () {
                     document.getElementById("editPanel").classList.remove("hidden");
                     document.getElementById("newType").value = "Tarea"; // <-- This line sets the type
                     document.getElementById("newCategory").value = category === 'Sin Categoría' ? '' : category; // Pre-fill with the current category
                      updateLivePreview(); // Update preview for new item
                       toggleSearchTermButton(); // Ensure search term button is hidden for Task type
                   });
                   categoryContainer.appendChild(addCard);
                 }
             }

             container.appendChild(categoryDiv);
         });
          console.log("Tareas renderizadas."); // Log exit
     }


    function populateEditTable(currentData) {
      console.log("Poblando tabla de edición..."); // Log entry
      const tableBody = document.getElementById("itemsTableBody");
      tableBody.innerHTML = "";
       // Sort data by type for better organization in the edit panel table
       const sortedData = [...currentData].sort((a, b) => {
           const typeOrder = ['Buscador', 'Link', 'Promp', 'Nota', 'Tarea'];
           return typeOrder.indexOf(a.type) - typeOrder.indexOf(b.type) || (a.title || '').localeCompare(b.title || ''); // Handle potential null/undefined titles
       });


      sortedData.forEach((item, index) => {
        const row = document.createElement("tr");
        row.className = index % 2 === 0 ? "bg-white" : "bg-gray-50";

        let actionInputHtml = `<input type="text" class="border border-gray-300 rounded px-2 py-1 w-full" value="${item.action || ''}">`;
        if (item.type === 'Promp' || item.type === 'Nota' || item.type === 'Tarea') {
             actionInputHtml = `<textarea class="border border-gray-300 rounded px-2 py-1 w-full h-20">${item.action || ''}</textarea>`;
        }

        let completedCheckboxHtml = '';
        if (item.type === 'Tarea') {
            completedCheckboxHtml = `<div class="flex items-center mt-1"><input type="checkbox" class="edit-completed mr-2" ${item.completed ? 'checked' : ''}> <label class="text-sm font-medium">Completada</label></div>`;
        }


        row.innerHTML = `
          <td class="px-6 py-4 whitespace-nowrap"><input type="text" class="border border-gray-300 rounded px-2 py-1 w-full" value="${item.title || ''}"></td>
          <td class="px-6 py-4">${actionInputHtml}${completedCheckboxHtml}</td>
          <td class="px-6 py-4 whitespace-nowrap">
            <select class="border border-gray-300 rounded px-2 py-1 w-full">
              <option value="Buscador" ${item.type === "Buscador" ? "selected" : ""}>Buscador</option>
              <option value="Link" ${item.type === "Link" ? "selected" : ""}>Link</option>
              <option value="Promp" ${item.type === "Promp" ? "selected" : ""}>Prompt</option>
              <option value="Nota" ${item.type === "Nota" ? "selected" : ""}>Nota</option>
              <option value="Tarea" ${item.type === "Tarea" ? "selected" : ""}>Tarea</option>
            </select>
          </td>
          <td class="px-6 py-4 whitespace-nowrap"><input type="text" class="border border-gray-300 rounded px-2 py-1 w-full" value="${item.category || ''}"></td>
          <td class="px-6 py-4 whitespace-nowrap"><input type="text" class="border border-gray-300 rounded px-2 py-1 w-full" value="${item.icon || ""}"></td>
          <td class="px-6 py-4 whitespace-nowrap">
            <button class="update-item-btn text-blue-600 hover:text-blue-800 mr-3" data-id="${item.id}"><i class="fas fa-save"></i></button>
            <button class="delete-item-btn text-red-600 hover:text-red-800" data-id="${item.id}"><i class="fas fa-trash-alt"></i></button>
          </td>
        `;
        // Update event listener for table save button
        row.querySelector(".update-item-btn").addEventListener("click", function () {
          const itemId = this.getAttribute("data-id");
          // Select inputs relative to the row
          const inputs = row.querySelectorAll("input[type='text'], textarea, select");
          const updatedItem = {
            id: itemId,
            title: inputs[0].value,
            action: inputs[1].value, // This gets value from input or textarea
            type: inputs[2].value, // The select element
            category: inputs[3].value,
            icon: inputs[4].value
          };
           if (updatedItem.type === 'Tarea') {
                // Assuming the completed checkbox is always the last input in the row if type is Tarea
               const completedCheckbox = row.querySelector(".edit-completed");
               if (completedCheckbox) {
                  updatedItem.completed = completedCheckbox.checked;
               } else {
                   // If checkbox is missing, maybe default to false or current state
                   console.warn("Completed checkbox not found for Tarea item.");
                   const existingItem = data.find(item => item.id == itemId);
                   updatedItem.completed = existingItem ? existingItem.completed : false;
               }
           }
          updateItem(itemId, updatedItem);
        });
        // Update event listener for table delete button
        row.querySelector(".delete-item-btn").addEventListener("click", function () {
          const itemId = this.getAttribute("data-id");
          if (confirm("¿Estás seguro de que deseas eliminar este elemento?")) {
             deleteItem(itemId);
          }
        });
        tableBody.appendChild(row);
      });
       console.log("Tabla de edición poblada."); // Log exit
    }


    // --- Funciones de Importación/Exportación ---


    // Function to export data to JSON file
    function exportData() {
        console.log("Exportando datos..."); // Log export
        const jsonData = JSON.stringify(data, null, 2); // Use null, 2 for pretty printing
        const blob = new Blob([jsonData], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = "centro_accesos_data.json";
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showToast("Datos exportados correctamente.");
         console.log("Datos exportados."); // Log export complete
    }

    // Function to import data from JSON file
    function importData(file) {
        console.log("Importando datos..."); // Log import
        const reader = new FileReader();
        reader.onload = function(event) {
            try {
                const importedData = JSON.parse(event.target.result);
                if (Array.isArray(importedData)) {
                     // Optional: Add validation for imported data structure
                     if (confirm("¿Estás seguro de que deseas reemplazar tus datos actuales con los datos importados?")) {
                          // Ensure imported items have IDs, add if missing
                          data = importedData.map(item => {
                              if (item.id === undefined || item.id === null) {
                                  item.id = Date.now().toString() + Math.floor(Math.random() * 1000000).toString(); // Generate a more unique ID
                              }
                              // Ensure imported tasks have completed status if missing
                               if (item.type === 'Tarea' && item.completed === undefined) {
                                   item.completed = false;
                               }
                               return item;
                           });
                          saveData(data); // Save imported data to localStorage
                          initializeUI(data); // Re-render UI and re-populate edit table
                          showToast("Datos importados correctamente.");
                           console.log("Datos importados y UI actualizada."); // Log import complete
                     } else {
                        console.log("Importación cancelada por el usuario."); // Log cancellation
                     }
                } else {
                    showToast("El archivo JSON no tiene el formato esperado (debe ser un array).");
                    console.error("Error de formato de archivo JSON importado."); // Log error
                }
            } catch (e) {
                showToast("Error al leer o analizar el archivo JSON.");
                console.error("Import error:", e); // Log error details
            }
        };
        reader.readAsText(file);
         // Reset the file input value to allow importing the same file again
         document.getElementById("importDataInput").value = '';
    }


    // --- Inicialización ---

    // Búsqueda inteligente: se utiliza un datalist para sugerir términos
    let searchHistory = JSON.parse(localStorage.getItem("searchHistory")) || [];
    function updateSearchSuggestions() {
      const dataList = document.getElementById("searchSuggestions");
      dataList.innerHTML = "";
      searchHistory.forEach(term => {
        const option = document.createElement("option");
        option.value = term;
        dataList.appendChild(option);
      });
    }


    document.addEventListener("DOMContentLoaded", function () {
        console.log("DOM completamente cargado. Intentando cargar datos desde localStorage.");

         // Apply dark mode preference immediately on DOMContentLoaded
         const darkModePreference = localStorage.getItem("darkMode");
         const toggleDarkModeBtn = document.getElementById("toggleDarkMode");
         const modeIcon = toggleDarkModeBtn.querySelector("i");
         const modeText = toggleDarkModeBtn.querySelector(".mode-text");

        if (darkModePreference === "enabled") {
            document.body.classList.add("dark");
            modeIcon.classList.remove("fa-moon");
            modeIcon.classList.add("fa-sun");
            modeText.textContent = "Modo Claro";
        } else {
            modeIcon.classList.remove("fa-sun");
            modeIcon.classList.add("fa-moon");
            modeText.textContent = "Modo Oscuro";
        }

        // Intenta cargar desde localStorage primero
        const savedData = localStorage.getItem("centroAccesosData");
        if (savedData) {
            try {
                data = JSON.parse(savedData);
                console.log("Datos cargados desde localStorage:", data);
                 // Ensure items have an ID if loading old data, and tasks have a completed status
                data = data.map(item => {
                     if (item.id === undefined || item.id === null) {
                         item.id = Date.now().toString() + Math.floor(Math.random() * 1000000).toString(); // Generate a simple ID if missing
                     }
                    if (item.type === 'Tarea' && item.completed === undefined) {
                        return { ...item, completed: false };
                    }
                    return item;
                });
                initializeUI(data);
                setupNavigation();
                setupEventListeners();
                updateSearchSuggestions(); // Update search suggestions on load
                console.log("Inicialización completa con datos de localStorage.");
            } catch (e) {
                console.error("Error al parsear datos de localStorage:", e);
                showToast("Error al cargar datos guardados. Se iniciará con datos vacíos.");
                 // Initialize with empty UI if localStorage fails
                 data = [];
                 initializeUI(data);
                 setupNavigation();
                 setupEventListeners();
                 updateSearchSuggestions(); // Update search suggestions even with empty data
                 console.log("Inicialización completa con datos vacíos debido a error de localStorage.");
            }
        } else {
            console.log("No se encontraron datos en localStorage. Intentando cargar desde data.json...");
            // If no data in localStorage, try loading from data.json (original source)
            loadDataFromJson(); // loadDataFromJson calls initializeUI, setupNavigation, setupEventListeners, and updateSearchSuggestions
             console.log("Iniciando carga desde data.json...");

        }

        // Ensure toggleDarkModeBtn listener is added after button exists
        toggleDarkModeBtn.addEventListener("click", function() {
          document.body.classList.toggle("dark");
          if (document.body.classList.contains("dark")) {
              localStorage.setItem("darkMode", "enabled");
              modeIcon.classList.remove("fa-moon");
              modeIcon.classList.add("fa-sun");
              modeText.textContent = "Modo Claro";
          } else {
              localStorage.setItem("darkMode", "disabled");
              modeIcon.classList.remove("fa-sun");
              modeIcon.classList.add("fa-moon");
              modeText.textContent = "Modo Oscuro";
          }
        });
    });

  </script>
</body>
</html>
